# #17 InnoDB 클러스터

- MySQL 서버 자체적으로 페일오버를 처리하는 기능을 제공하지 않았으므로 사용자는 MySQL의 복제 기능을 사용해 서비스의 고가용성을 실현할 수 있지만 단순히 현재 사용중인 MySQL 서버들을 소스-레플리카 구조의 복제 형태로 구성해놓는다고 해서 고가용성이 실현되는 것은 아니었다.
- 기존에는 서버 장애를 감지해 자동으로 페일오버 처리하는 프로그램을 직접 개발하거나 서드 파티 HA 솔루션을 사용했는데 MySQL 5.7.17 버전에서 빌트인 형태의 HA 솔루션인 InnoDB 클러스터가 도입되면서 사용자는 좀 더 쉽고 편리하게 고가용성을 실현할 수 있게 됐다.
- InnoDB 클러스터는 MySQL 8.0 이후에도 계속 신규 기능들이 들어오고 있고 버전별로 많은 기능의 차이를 보인다. InnoDB 클러스터를 사용한다면 가능한 한 최신 버전의 MySQL 서버를 사용할 것을 권장한다. 



## InnoDB 클러스터 아키텍처

- InnoDB 클러스터는 단순하게 MySQL 서버 내에서 설정할 수 있는 어떤 특정한 기능이 아닌 MySQL의 고가용성 실현을 위해 만들어진 여러 구성 요소들의 집합체다.

`InnoDB 클러스터를 구성하는 요소`

- 그룹 복제
  - 소스 서버의 데이터를 레플리카 서버로 동기화하는 기본적인 복제 역할뿐만 아니라 복제에 참여하는 MySQL 서버들에 대한 자동화된 멤버십 관리 역할을 담당한다.
- MySQL 라우터
  - 애플리케이션 서버와 MySQL 서버 사이에서 동작하는 미들웨어 프로그램으로, 애플리케이션이 실행한 쿼리를 적절한 MySQL 서버로 전달하는 프락시 역할을 한다.
- MySQL 셸
  - 기존 MySQL 클라이언트보다 좀 더 확장된 기능을 가진 새로운 클라이언트 프로그램.
  - 기본적인 SQL문 뿐만 아니라 자바스크립트 및 파이썬 기반의 스크립트 작성 기능과 MySQL 서버에 대해 클러스터 구성 등의 어드민 작업을 할 수 있게 하는 API를 제공한다.

<br/>



![87](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/87.jpeg)



- InnoDB 클러스터에서 데이터가 저장되는 MySQL 서버들은 그룹 복제 형태로 복제가 구성되며 각 서버는 읽기/쓰기가 모두 가능한 프라이머리 혹은 읽기만 가능한 세컨더리중 하나의 역할로 동작하게 된다.
- 그룹 복제에서는 InnoDB 스토리지 엔진만 사용될 수 있는데 이것이 바로 InnoDB 클러스터라고 명명된 이유라 할 수 있다.
- 그룹 복제를 구성할 때 고가용성을 위해 MySQL 서버를 최소 3대 이상으로 구성해야 한다. 그래야 MySQL 서버 한 대에 장애가 발생하더라도 복제 그룹이 정상적으로 동작하기 때문이다.
- InnoDB 클러스터를 사용하는 환경에서 클라이언트는 MySQL 서버로 직접 접근해서 쿼리를 실행하는 것이 아니라 MySQL 라우터에 연결해서 쿼리를 실행한다.
- MySQL 라우터는 InnoDB 클러스터로 구성된 MySQL 서버들에 대한 메타데이터 정보를 지니며 이를 바탕으로 클라이언트로부터 실행된 쿼리를 클러스터 내 적절한 MySQL 서버로 전달한다. 따라서 클라이언트는 현재 InnoDB 클러스터가 어떤 서버로 구성돼 있는지 알고 있을 필요가 없고 커넥션 정보에는 MySQL 라우터 서버만 설정해두면 된다.
- MySQL 셸은 사용자가 손쉽게 InnoDB 클러스터를 생성하고 관리할 수 있도록 API를 제공하는 등의 여러가지 기능을 제공한다. 
- InnoDB 클러스터에서는 MySQL 서버에 장애가 발생하면 그룹 복제가 먼저 이를 감지해서 자동으로 해당 서버를 복제 그룹에서 제외시키며 MySQL 라우터는 이러한 복제 토폴로지 변경을 인지하고 자신이 가진 메타데이터를 갱신해서 클라이언트로부터 실행된 쿼리가 현재 복제 그룹에 정상적으로 동작하는 MySQL 서버로만 전달될 수 있다.
- 즉 기존에는 전부 수동으로 장애 복구 처리를 해야 했던 부분들이 InnoDB 클러스터에서는 모두 자동으로 처리된다.



## 그룹 복제 (Group Replication)

- 그룹복제는 MySQL 5.7.17 버전에서 도입된 새로운 복제 방식이고 기존 MySQL 복제 프레임워크를 기반으로 구현되어 내부적으로 Row 포맷의 바이너리로그와 릴레이 로그, GTID를 사용한다.
- 이처럼 기존 MySQL 복제와 구조적으로 유사한 부분도 있지만 복제 구성 형태, 트랜잭션 처리 방식 측면에서는 완전히 다른 복제 방식이다.
- 기존 복제의 경우 일반적으로 소스-레플리카 형태로 구성되어 단방향 복제인 반면 그룹 복제에서는 복제에 참여하는 MYSQL 서버들이 하나의 복제 그룹으로 묶인 클러스터 형태를 가지며 그룹 내 서버들은 서로 통신하는 양방향 복제처리를 할 수 있다. (하나의 복제 그룹에서 쓰기 처리하는 서버가 2대 이상일 수 있다.)
- 따라서 복제 그룹에서 소스-레플리카라는 용어는 사용하지 않고 프라이머리, 세컨더리라는 용어로 사용한다.
- 프라이머리는 쓰기 전용, 세컨더리는 읽기 전용, 그룹복제에 참여하는 MySQL 서버들은 그룹멤버 라고 지칭한다.
- 그룹 복제는 기존 복제와 복제 처리 방식에서도 큰 차이를 보인다.

`복제 방식`

![88](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/88.jpeg)



- 기존 복제에서는 기본적으로 소스 서버에서의 트랜잭션 커밋 처리가 레플리카 서버와는 무관하게 처리되는 비동기 방식으로 동작한다. 소스서버에서는 트랜잭션 커밋 시 레플리카 서버로도 해당 트랜잭션이 잘 전달 됐는지 확인하지 않는다.
- 반동기 방식은 트랜잭션 처리를 할 때 소스 서버와 레플리카 사이에 확인 단계가 하나 추가된 것으로 반동기방식을 사용하는 경우 소스 서버에서는 트랜잭션 커밋 처리 중 레플리카 서버로 트랜잭션이 잘 전달됐는지 응답을 기다린 후 최정적으로 커밋을 한다.
- 그룹 복제에서는 한 서버에서 트랜잭션이 커밋될 준비가 되면 트랜잭션 정보를 그룹의 다른 멤버들에게 전송하고 과반수 이상의 멤버로부터 응답을 전달받으면 그때 해당 트랜잭션을 인증하고 최종적으로 커밋 처리를 완료한다.
- 트랜잭션 인증은 인증 대상 트랜잭션이 이미 인증 단계를 통과한 선행 트랜잭션과 동시점에 동일한 데이터를 변경했는지 충돌 여부를 검사해서 문제 없이 적용 가능하지를 확인하는 과정이다.
- 그룹 복제에서 트랜잭션 커밋을 처리할 때 만약 과반수 이상의 멤버로부터 응답을 받지 못하면 해당 트랜잭션은 그룹에 적용되지 않는다.
- 가장 큰 차이점으로는 비동기, 반동기 방식 모두 복제 구성 내에서 트랜잭션은 소스 서버에서 일방적으로 적용되지만 그룹 복제에서는 그룹 내 멤버들의 응답에 따라 전체 복제 그룹에서 해당 트랜잭션의 적용 여부가 결정된다는 것이다.
- 그룹 복제에서 이처럼 트랜잭션 커밋을 처리할 때 그룹의 다른 멤버들에 대한 응답을 확인하는 과정을 '합의 Consensus' 라고 한다.
- 그룹 복제는 기존 복제 환경에서 수동처리되어야 하는 부분을 자동화된 기능으로 제공함으로써 사용자의 편의성을 증대시켰다.
- 그룹 복제에서 제공하는 대표적인 기능
  - 그룹 멤버 관리
  - 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지
  - 자동 페일오버
  - 자동 분산 복구



### 그룹 복제 아키텍처

- 그룹 복제는 별도 플러그인으로 구현돼 있고 그룹 복제를 사용하기 위해서는 MySQL 서버에 그룹 복제 플러그인이 설치 되어야 한다.

![89](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/89.jpeg)

- 그룹 복제에 참여하는 MySQL 서버들은 그룹 복제 플로그인을 통해 서로 간에 지속적으로 통신하며 복제 동기화 처리를 한다.
- 그룹 복제 플러그인은 MySQL 서버에 그룹 복제가 설정되면 `group_replication_applier` 라는 복제 채널을 생성해서 이 채널로 모든 트랜잭션을 전달받아 적용하게 된다.
- 그룹 복제 분산 복구 작업이 필요한 경우 `group_replication_recovery` 라는 복제 채널을 생성해서 분산 복구 작업을 진행한다.

`그룹 복제 플러그인의 내부 구조`

![90](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/90.jpeg)

`Plugin API 계층`

- 플러그인 최상위 계층에는 그룹 복제 플러그인이 MySQL 서버와 상호작용 하기 위해 구현된 인터페이스인 플러그인 API 집합이 존재한다.
- 플러그인 API를 통해 MySQL 서버에는 MySQL 서버의 시작 또는 복구, 트랜잭션 커밋 등의 이벤트를 그룹 복제 플러그인에 전달하고 그룹 복제 플러그인에서는 처리중인 트랜잭션에 대한 커밋 또는 중단, 릴레이 로그 기록을 위한 요청 등을 서버에 전달한다.

`Replication Plugin 계층`

- 그 다음 계층으로 그룹 복제의 기능들이 실질적으로 구현돼 있는 복제 플러그인 계층이 존재한다. 
- 계층 내부는 여러 가지 모듈들로 나눠져 있으며, API를 통해 들어온 요청들은 각각 적절한 모듈로 전달된다.
- 이 계층에서는 로컬 및 그룹 복제의 다른 MySQL 서버에서 실행된 원격 트랜잭션들이 처리되며 트랜잭션들에 대한 충돌 감지 및 그룹 내 전파 등이 수행된다.

`Group Communication System API & Group Communication Engine (XCom)`

- 마지막 두 계층은 그룹 통신 시스템 API와 그룹 통신 엔진으로 이루어져 있다.
- 상위 플러그인 계층에서는 그룹 통신 시스템 API를 통해 그룹 통신 엔진과 상호작용한다.
- 그룹 통신 엔진은 eXtended COMmunication 또는 간단하게 XCom 이라고 한다.
- 그룹 복제에 참여중인 다른 MySQL 서버들과 통신 처리를 담당하는 그룹 복제의 핵심 구성 요소다.

<br>

- 그룹 복제에서 또 다른 중요한 부분은 바로 그룹 복제를 구성하는 MySQL 서버의 수다.
- 그룹 복제에서는 복제를 처리할 때 그룹 멤버들 간에 합의 절차가 수행되므로 그룹 복제가 정상적으로 동작하려면 그룹의 과반수에 해당하는 서버가 정상적으로 동작하고 있어야 한다.
- 최소 세 대 이상 필요하다.
- 그룹 복제를 구성할 때 공식

```
n = 2f + 1 (n: 전체 서버 수, f: 허용하고자 하는 장애 서버 수)

3 -> 5 -> 7 -> 9 ... 홀수
```



### 그룹 복제 모드

- 그룹 복제에서는 쓰기를 처리할 수 있는 프라이머리 서버 수에 따라 싱글 프라이머리 모드, 멀티 프라이머리 모드라는 두 가지 동작 모드가 있다.
- 사용자는 `group_replication_single_primary_mode` 시스템 변수를 통해 그룹 복제들을 어떤 모드로 동작하게 할 것인지 설정할 수 있다.
- 값이 ON으로 지정되면 그룹 복제가 싱글 프라이머리 모드로 동작하고 OFF면 멀티 프라이머리 모드로 동작한다 (기본값은 ON)
- MySQL 8.0.13 이상 버전일 경우에만 그룹 복제 모드가 동작중인 상황에서 변경할 수 있고 그 이하 버전은 그룹 복제를 중단한 후 그룹의 모든 멤버들에서 `group_replication_single_primary_mode`를 변경해야 한다.
- MySQL 8.0.13 이상 에서 아래와 같이 동작중에 변경가능하다.
  - `group_replication_switch_to_single_primary_mode()` : 그룹 복제의 모드를 싱글 프라이머리 모드로 변경
  - `group_replication_switch_to_multi_primary_mode()` : 그룹 복제의 모드를 멀티 프라이머리 모드로 변경

#### 싱글 프라이머리 모드

- 싱글 프라이머리 모드는 그룹 내에서 쓰기를 처리할 수 있는 프라이머리 서버가 한 대만 존재하는 형태다
- 싱글 프라이머리 모드로 그룹 복제를 처음 구축하는 경우 그룹 복제 구축을 진행한 MySQL 서버가 프라이머리로 지정된다.
- 그룹에서 프라이머리 서버가 아닌 다른 서버들은 그룹에 참여하는 시점에 자동으로 `super_read_only` 시스템 변수가 ON으로 설정되어 읽기 전용 모드로 동작하게 된다.
- `super_read_only` 가 ON으로 설정되면 SUPER 권한이 있는 사용자도 업데이트가 불가능해진다. since 5.7

![91](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/91.jpeg)



- 싱글 프라이머리 모드로 동작중인 그룹에서는 다음과 같은 상황에서 그룹 내 프라이머리 서버가 변경될 수 있다.
  - 자발적으로 혹은 예기치않게 현재 프라이머리 서버가 그룹을 탈퇴하는 경우
  - `group_replication_set_as_primary()` UDF(User Define Function)를 사용해 그룹의 특정 멤버를 새로운 프라이머리로 지정한 경우 (MySQL 8.0.13 이상의 버전을 사용할 경우에 해당)
- 현재 그룹의 프라이머리가 `group_replication_set_as_primary()`  UDF를 통해 사용자가 지정한 서버로 변경되는 것이 아닌 경우 그룹 복제에서는 정해진 기준들을 바탕으로 새로운 프라이머리를 선출하게 되는데 그룹 복제에서 고려하는 기준과 그 우선순위는 다음과 같다.

`1. MySQL 서버 버전`

- 그룹 내에서 가장 낮은 MySQL 버전을 실행중인 멤버를 확인한다. 이를 위해 그룹 내에서 사용중인 MySQL 버전을 정렬하게 되는데 이 역시 MySQL 버전에 따라 정렬 기준이 조금 다르다.
- 모든 그룹 멤버가 MySQL 8.0.17 이상의 버전을 사용중인 경우 먼저 패치 버전을 기준으로 정렬된다. 만약 MySQL 8.0.17 미만의 버전을 사용하고 있는 멤버가 존재하는 경우 메이저 버전을 기준으로 정렬되며 패치 버전은 무시된다.

`2.각 멤버의 가중치 값` 

- 그룹 내에서 가장 낮은 MySQL 버전을 실행 중인 것으로 확인된 멤버가 둘 이상 존재하는 경우 그룹 복제는 해당 멤버들에서 `group_replication_member_weight` 시스템 변수에 지정된 가중치 값을 비교한다.
- `group_replication_member_weight` 시스템 변수는 MySQL 5.7.20 버전부터 도입됐고 만약 그룹 내에 MySQL 5.7.20 버전 미만의 MySQL 서버가 있으면 이 기준은 무시된다.
- `group_replication_member_weight` 의 기본값은 50이다.

`3.UUID 값의 사전식 순서`

- MySQL 서버 버전과 가중치를 기준으로 선정된 멤버가 둘 이상 존재하는 경우 해당 멤버들이 가지는 UUID 값의 사전식 순서를 바탕으로 가장 낮은 값을 가지는 멤버가 그룹의 새로운 프라이머리로 최종 선택된다.

<br>

- 현재 싱글 프라이머리 모드로 동작중인 그룹 복제에서 어떤 서버가 프라이머리인지는 아래와 같이 확인할 수 있다.

```sql
SELECT *
FROM performance_schema.replication_group_members;
```

![92](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/92.png)

> innodb-cluster docker-compose github
>
> - [https://github.com/neumayer/mysql-docker-compose-examples](https://github.com/neumayer/mysql-docker-compose-examples)





#### 멀티 프라이머리 모드

- 멀티 프라이머리 모드는 그룹 복제에서 그룹 멤버들이 전부 프라이머리로 동작하는 형태로 클라이언트는 그룹의 어떤 MySQL 서버로든 쓰기와 읽기 요청을 보낼 수 있다.

![93](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/93.jpeg)

- 멀티 프라이머리 모드를 사용하는 구룹에서는 최적의 호환성과 성능을 위해 그룹의 모든 멤버가 동일한 MySQL 버전으로 실행되는 것이 좋다. 만약 서로 다른 경우 특정 서버에 기능이 없거나 호환이 되지 않을 가능성이 있다.
- 이를 방지하기 위해 그룹 복제에서는 서로 다른 버전을 사용중인 그룹 멤버들 간에 복제가 정상적으로 동작할 수 있도록 그룹복제에 참여할 때 버전호환성을 확인하는 기능이 구현되어 있다.
- 그룹복제에서 정의한 호환 가능 기준에 따라 그룹 참여 가능 여부와 읽기 전용 모드 유지 여부를 결정하게 된다. 

`그룹 복제에서 버전에 따른 호환 가능 기준`

1. 새로운 멤버가 그룹에 존재하는 가장 낮은 MySQL 버전보다 낮은 버전을 사용중인 경우 그룹에 참여할 수 없다.
2. 새로운 멤버가 그룹에 존재하는 가장 낮은 MySQL 버전보다 동일한 버전을 사용중인 경우 정상적으로 그룹에 참여할 수 있다.
3. 멀티 프라이머리 모드의 그룹에서는 새로운 멤버가 그룹에 존재하는 가장 낮은 MySQL 버전보다 높은 MySQL 버전을 사용중인 경우 그룹에 참여할 수는 있지만 읽기 전용 모드를 유지하게 된다. (싱글 프라이머리 모드라면 버전에 상관없이 새로 참여하는 멤버는 무조건 읽기 전용 모드)

<br>

- MySQL 8.0.17 이상의 버전을 사용하는 멤버들은 호환 가능 여부에 따라 그룹 복제에서 읽기 전용 및 읽기-쓰기 모드전환을 자동으로 처리한다.
- 그룹에서 한 멤버가 탈퇴하면 멀티 프라이머리 모드의 그룹 복제에서는 이를 감지해서 현재 그룹 내에서 가장 낮은 MySQL 버전을 사용하는 멤버를 다시 확인한 후 해당 멤버를 자동으로 읽기-쓰기 모드로 전환시킨다. 
- 만약 싱글 프라이머리 모드로 실행중에 `group_replication_switch_to_multi_primary_mode()` UDF를 통해 멀티 프라이머리 모드로 전환되는 경우 그룹 내 멤버들의 MySQL 버전을 바탕으로 각 멤버들을 자동으로 적절한 모드로 설정한다.
- 그룹 내에서 사용중인 가장 낮은 MySQL 버전보다 높은 MySQL 버전을 사용중인 멤버들은 읽기 전용 모드로 설정하고 가장 낮은 버전을 사용하는 것으로 확인되는 멤버들은 읽기-쓰기 모드로 설정한다.



### 그룹 멤버 관리 (Group Membership)

- 그룹 복제에서는 현재 어떤 서버들이 그룹에 참여하고 있는지 그룹 멤버들에 대한 목록과 상태 정보를 내부적으로 관리하고 있고 사용자는 `performance_schema.replication_group_members` 테이블을 통해 그룹 멤버 목록을 확인할 수 있다.

```sql
SELECT *
FROM performance_schema.replication_group_members;
```

![92](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/92.png)

`MEMBER_STATE 종류`

1. `ONLINE`: 그룹 복제의 한 구성원으로서 정상적으로 있음을 나타낸다.
2. `RECOVERING`: 그룹 복제에 참여하기 위해 그존 그룹 멤버로부터 데이터를 전달받는 복구 작업이 진행되고 있음을 나타낸다.
3. `OFFLINE`: MySQL 서버에 그룹 복제 플러그인이 로딩돼 있으나 아직 그룹 복제에 참여하지 않은 상태를 나타낸다.
4. `ERROR`: 그룹 복제에 속해 있으나 현재 정상적으로 복제가 동작하지 않고 있는 상태를 나타낸다. 복제 동기화에 오류가 발생하는 등의 문제로 이 같은 상태가 표시될 수 있으며, 그 외에도 다양한 문제들로 인해 그룹 멤버의 상태 값이 이 값으로 표시될 수 있다.
5. `UNREACHABLE`: 현재 통신이 불가능하다고 판단되는 멤버에 대해 표시하는 상태 값이다.

<br>

- 그룹 복제가 관리하는 멤버 목록과 상태 정보를 뷰(View) 라고도 하는데 그룹 복제에서 멤버는 새로 가입하거나 탈퇴할 수 있으므로 뷰는 특정 시점의 그룹 멤버 목록이라고 할 수 있다.
- 뷰는 뷰 ID라는 고유 식별자를 갖고 있고 그룹 멤버가 변경될 때마다 새로운 뷰 ID 값이 생성된다.
- 뷰 ID는 각각의 변경된 뷰를 고유하게 식별하는 것이고 그룹 복제는 이를 통해 뷰의 변경을 추적하고 뷰가 변경된 시점을 구분할 수 있다.

```
View ID = [Prefix value]:[Sequence value]

Prefix value = 그 시점의 타임스탬프를 기반
Sequence value = 1부터 증가하는 정수값
```



![94](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/94.jpeg)





```sql
SELECT VIEW_ID FROM performance_schema.replication_group_member_stats;

+---------------------+
| VIEW_ID             |
+---------------------+
| 16472972986347547:3 |
| 16472972986347547:3 |
| 16472972986347547:3 |
+---------------------+
```

- 그룹에 새로운 멤버가 추가되어 뷰가 변경되는 경우엔 바이너리 로그에도 "View_change" 라는 이벤트로 뷰 변경 내역이 기록된다.

```sql
SHOW BINLOG EVENTS IN 'mysql-bin.0000004' FROM 52559 LIMIT 1 \G
```



### 그룹 복제에서의 트랜잭션 처리

- 그룹 복제에서 트랜잭션은 합의 또는 인증 단계들을 거친 후 최종적으로 그룹의 각 서버들에 적용된다.
- 합의(Consensus)는 그룹 내 일관된 트랜잭션 적용을 위해 그룹 멤버들에게 트랜잭션 적용을 제안하고 승낙을 받는 과정으로 그룹 멤버 간의 통신 결과를 바탕으로 처리된다. 
- 클라이언트가 한 그룹 멤버에게 트랜잭션을 실행하고 커밋 요청을 보내면 해당 그룹 멤버는 그룹 통신 엔진(XCom)을 통해 트랜잭션에서 변경한 데이터에 대한 WriteSet과 트랜잭션이 커밋될 당시의 트랜잭션의 이벤트 로그 데이터 등이 포함된 트랜잭션 데이터를 그룹의 다른 멤버들로 전파한다. 
- 그룹 복제의 그룹 통신 엔진에서는 트랜잭션 데이터를 전파하면서 Paxos 기반의 프로토콜을 바탕으로 그룹 멤버들 간의 합의를 수행하며 최종적으로 합의가 완려되어 트랜잭션이 실행된 멤버에서 그룹의 과반수 이상에 해당하는 멤버들로부터 응답 메시지를 전달받으면 해당 멤버는 그 다음 프로세스를 진행하게 된다.

> Paxos 프로토콜
>
> [https://ko.wikipedia.org/wiki/%ED%8C%A9%EC%86%8C%EC%8A%A4_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)](https://ko.wikipedia.org/wiki/%ED%8C%A9%EC%86%8C%EC%8A%A4_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))

- 만약 과반수 이상의 멤버들로부터 응답을 받지 못하면 그룹 복제에서 트랜잭션은 적용되지 않으며 클라이언트에는 에러가 반환된다.
- 다수의 그룹 멤버들에서 실행된 트랜잭션들은 합의 단계를 거친 후 글로벌하게 정렬되어 각 멤버들에게서 모두 동일한 순서로 인증(Certification) 단계를 거치게 된다. 
- 인증 단계에서 각 멤버들은 전달받은 트랜잭션 WriteSet 데이터와 로컬에서 내부적으로 관리하고 있는 WriteSet 히스토리 데이터를 바탕으로 해당 트랜잭션이 이미 인증 단계를 거친 선행 트랜잭션과 동시점에 동일한 데이터를 변경한 것인지를 검사해서 트랜잭션 충돌 여부를 확인한다.
- 이런 트랜잭션 충돌 현상은 멀티 프라이머리모드에서만 발생한다.
- 인증 단계에서 트랜잭션 충돌이 감지된 트랜잭션은 커밋되지 못하고 롤백된다. 트랜잭션 충돌이 자주 발생할 수 있는 환경에서는 그룹 복제를 싱글 프라이머리 모드로 사용하는게 더 나은 방법이 될 수 있다.
- 각 트랜잭션이 실행된 로컬 멤버에서는 인증 단계를 거친 후 바이너리 로그에 트랜잭션을 기록하고 최종적으로 커밋을 완료하며 클라이언트는 이 시점에 커밋 요청에 대한 응답을 받게 된다.
- 원격으로 트랜잭션 데이터를 전달받은 그룹의 다른 멤버들에서는 인증 단계를 수행한 후 함께 전달받은 트랜잭션 로그 데이터를 바탕으로 릴레이 로그 이벤트를 작성한다. 
- 복제 그룹의 어플라이어 스레드에서는 릴레이 로그에 기록된 트랜잭션을 실행하고 바이너리 로그에도 기록해서 최종적으로 서버에 해당 트랜잭션을 적용하게 된다.



![95](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/95.jpeg)

#### 트랜잭션 일관성 수준

- 그룹 복제에서 각 멤버들은 모두 동일한 트랜잭션을 적용하지만 실제 적용 시점까지는 완전히 일치하진 않는다. 한 멤버에서 쓰기를 수행한 후 바로 다른 멤버에서 해당 데이터를 읽었을 때 최신 변경사항이 반영되지 않았을 수 있다.
- 프라이머리 장애로 인해 페일오버가 발생하는 경우 새로 선출된 프라이머리가 아직 이전 프라이머리에서 발생했던 트랜잭션을 적용하지 못했다면 오래된 데이터를 읽거나 쓸 수 있다.
- 일반적으로 그룹 복제가 정상적으로 잘 동작하고 있는 상태에서 멤버 간 데이터 동기화는 빠르게 처리되므로 이 같은 상황은 거의 발생하지 않지만 일시적으로 아주 짧은 순간에 발생할 수 있으며 이런 상황이 매우 민감한 서비스에서는 문제가 될 수 있다.
- MySQL 8.0.14버전까지는 위와 같은 상황이 발생하는 것을 방지할 수 있는 방법이 없었지만 8.0.14 버전부터 그룹 복제에서 트랜잭션의 일관성 수준을 설정할 수 있는 기능이 도입되면서 사용자가 필요에 따라 원하는 수준의 일관성을 선택해서 사용할 수 있게 됐다.
- `group_replication_consisitency` 시스템 변수를 통해 그룹 복제에서의 트랜잭션 일관성 수준을 설정할 수 있으며, 적용 범위는 글로벌 또는 세션 모두 가능하다.
- 설정된 일관성 수준은 읽기 전용 트랜잭션과 읽기-쓰기 트랜잭션에 다른 영향을 미치며 경우에 따라 다른 멤버에서 실행중인 트랜잭션에도 영향을 줄 수 있다.



##### EVENTUAL 일관성 수준

- `EVENTUAL` 일관성 수준은 `group_replication_consisitency` 시스템 변수의 기본 설정값으로 해당 변수가 추가되기 전의 그룹 복제에서의 트랜잭션 일관성 수준과 동일하다.
- 최종적으로는 그룹 멤버들이 일관된 데이터를 가지게 됨을 의미한다.
- `EVENTUAL` 일관성 수준에서는 읽기 전용 및 쓰기 읽기-쓰기 트랜잭션이 별도의 제약 없이 바로 실행 가능하다.
- 위 의미는 트랜잭션이 직접 실행된 멤버가 아닌 다른 그룹의 멤버들에서는 일시적으로 변경직전 상태의 데이터가 읽혀질 수 있고 프라이머리 페일오버가 발생한 경우 새로운 프라이머리가 이전 프라이머리의 트랜잭션을 모두 적용하기 전에 새로운 프라이머리에서 트랜잭션이 실행 가능하므로 오래된 트랜잭션을 읽을 수 있고 읽기-쓰기 트랜잭션의 경우 커밋 시점에 이전 프라이머리의 트랜잭션과의 충돌로 인해 롤백될 수 있음을 의미한다.

![96](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/96.jpeg)



##### BEFORE_ON_PRIMARY_FAILOVER 일관성 수준

- `BEFORE_ON_PRIMARY_FAILOVER ` 일관성 수준은 싱글 프라이머리 모드로 설정된 그룹 복제에서 프라이머리 페일 오버가 발생해서 신규 프라이머리가 선출됐을 때만 트랜잭션에 영향을 미친다. 
- 새로운 프라이머리가 `BEFORE_ON_PRIMARY_FAILOVER ` 일관성 수준이면 아직 이전 프라이머리에서 트랜잭션을 적용하고 있는 경우 새로운 프라이머리로 유입된 읽기, 읽기-쓰기 트랜잭션은 새로운 프라이머리에서 이전 프라이머리의 트랜잭션이 모두 적용될 때까지 처리되지 못하고 대기하게 된다.



![97](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/97.jpeg)

- 페일오버가 발생하기 직전까지 멤버간 복제 동기화가 정상적으로 잘 처리되었다면 트랜잭션 갭은 매우 적을 테지만 그렇지 못할 경우 클라이언트에서 응답 지연을 겪을 수 있으므로 클라이언트 단에서는 이 같은 지연을 대비하는 코드가 구현돼 있는 것이 좋다.
- 트랜잭션은 영원히 대기할 수 없고 MySQL의 `wait_timeout` 시스템 변수에 설졍된 값을 초과하면 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다. 기본값은 8시간(28,800) 이므로 적절히 쿼리의 타임아웃을 설정하는 것이 좋다.

`BEFORE_ON_PRIMARY_FAILOVER 일관성 수준에서 보장하는 것들`

1. 신규 프라이머리로 유입된 읽기 전용 및 읽기-쓰기 트랜잭션들은 오래된 데이터가 아닌 최신 데이터를 바탕으로 동작하게 된다.
2. 신규 프라이머리로 유입된 읽기-쓰기 트랜잭션은 적용 대기 중인 이전 프라이머리의 트랜잭션과의 충돌로 롤백될 수 있지만 `BEFORE_ON_PRIMARY_FAILOVER ` 에서는 이 같은 롤백은 발생하지 않는다.

<br>

- `BEFORE_ON_PRIMARY_FAILOVER ` 를 사용한다고 하더라도 모든 종류의 읽기 쿼리들이 전부 처리가 지연되는 것은 아니고 MySQL 서버 모니터링을 위한 일부 쿼리들은 바로 실행이 가능하다
  - `SHOW`
  - `SET`
  - `DO`
  - `EMPTY`
  - `USE`
  - `performance_schema` 및 `sys` 데이터베이스에 대한 `SELECT` 문 사용
  - `information_schema` 데이터베이스의 `PROCESSLIST` 테이블에 대한 `SELECT` 문 사용
  - 테이블 또는 사용자 정의 함수를 사용하지 않는 `SELECT` 문
  - `STOP GROUP_REPLICATION` 문
  - `SHUTDOWN` 문
  - `RESET PERSIST` 문
- `BEFORE_ON_PRIMARY_FAILOVER ` 는 페일오버가 일어나지 않는 일반적인 상황에서는 `EVENTUAL` 일관성 수준으로 설정된 트랜잭션 처럼 처리된다.

##### BEFORE 일관성 수준

- `BEFORE` 일관성 수준에서 읽기 전용 및 읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 완료될 때까지 대기 후 처리된다.
- 선행 트랜잭션은 해당 트랜잭션이 시행된 그룹 멤버에서의 선행 트랜잭션만을 의미한다.



![98](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/98.jpeg)

- `BEFORE` 일관성 수준으로 설정된 `T2` 트랜잭션은 Member3서버에서 `T1` 트랜잭션이 적용되고 난 후에 바로 실행이 가능하다.
- `BEFORE` 일관성 수준으로 설정된 읽기 전용 및 읽기-쓰기 트랜잭션은 항상 최신 데이터를 읽고 트랜잭션의 처리 시간은 선행 트랜잭션의 처리 시간에 영향을 받는다.
- `BEFORE` 일관성 수준으로 설정된 트랜잭션은 MySQL의 `wait_timeout` 시스템 변수에 설정된 시간까지 대기할 수 있고 대기시간이 초과하는 경우 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다. 
- `BEFORE` 일관성 수준은 트랜잭션에서 반드시 최신 데이터를 읽어야 하며, DB에서 읽기 요청은 적고 쓰기 요청이 많은 경우에 사용하는 것이 좋다.
- `BEFORE` 일관성 수준에서는 `BEFORE_ON_PRIMARY_FAILOVER` 수준이 제공하는 일관성도 보장한다.



##### AFTER 일관성 수준

- `AFTER` 일관성 수준은 트랜잭션이 적용되면 해당 시점에 그룹 멤버들이 모두 동기화된 데이터를 갖게 한다. 
- `AFTER` 일관성 수준에서 읽기-쓰기 트랜잭션은 다른 모든 멤버들에서도 해당 트랜잭션이 커밋될 준비가 됐을 때까지 대기한 후 최종적으로 처리되며 읽기 전용 트랜잭션은 데이터 변경을 발생시키지 않으므로 별도의 제약 없이 바로 처리된다.



![99](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/99.jpeg)

- `AFTER` 일관성 수준으로 설정된 읽기-쓰기 트랜잭션은 다른 그룹의 멤버들로부터 응답을 받으면 최종적으로 커밋된다.
- `AFTER` 일관성 수준은 다른 멤버에서 동시점에 실행되는 트랜잭션에 영향을 미치는데 `AFTER` 일관성 수준의 트랜잭션이 완전히 커밋될 때까지 대기하게 된다.
- `AFTER` 일관성 수준에서는 읽기-쓰기 트랜잭션이 그룹 모든 멤버들에서 커밋 준비가 된 후에야 트랜잭션이 실행된 로컬 멤버에서 최종적으로 커밋되므로 이후 실행되는 후속 트랜잭션들은 그룹의 어떤 멤버에서든 일관된 최신 데이터를 얻을 수 있다.
- `AFTER` 일관성 수준은 DB에서 쓰기 요청보다 읽기 요청이 많고, 분산된 최신 읽기를 수행하고자 할 때 사용하는 것이 좋다.
- `AFTER` 일관성 수준에서는 `BEFORE_ON_PRIMARY_FAILOVER` 수준이 제공하는 일관성도 보장한다.
- `AFTER` 일관성 수준으로 설정된 트랜잭션은 MySQL의 `wait_timeout` 시스템 변수에 설정된 시간까지 대기할 수 있고 대기시간이 초과하는 경우 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다. 



##### BEFORE_AND_AFTER 일관성 수준

- `BEFORE_AND_AFTER` 일관성 수준은 `BEFORE` 와 `AFTER` 가 결합된 형태라고 할 수 있다.
- `BEFORE_AND_AFTER` 일관성 수준에서 읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 기다린 후 실행되며 트랜잭션이 다른 모든 멤버들에서도 커밋이 준비되어 응답을 보내면 그 때 최종적으로 커밋된다. 읽기 전용 트랜잭션은 모든 선행 트랜잭션이 적용될 때까지 대기한 후 실행된다.





![100](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/100.jpeg)



- `BEFORE_AND_AFTER` 일관성 수준으로 설정되어 Member 1에서 실행된 트랜잭션 `T2`는 Member 3에서 실행된 트랜잭션 `T1`이 Member 1에서 적용될 때까지 대기 후 실행된다. 
- `T2`는 다른 멤버들에서도 트랜잭션 커밋이 준비됐을 때 최종적으로 커밋 처리된다.
- `T2` 가 완전히 적용되기 전에 Member 3로 유입된 `T3`은 `T2`가 적용될 때 까지 대기 후 실행된다.
- `BEFORE_AND_AFTER` 일관성 수준으로 설정된 트랜잭션에서는 최신 데이터를 읽을 수 있다.
- `BEFORE_AND_AFTER` 일관성 수준은 `AFTER`와 동일하게 다른 멤버들에서 실행되는 트랜잭션들에 영향을 미친다.
- `BEFORE_AND_AFTER` 일관성 수준에서는 `BEFORE_ON_PRIMARY_FAILOVER` 수준이 제공하는 일관성도 보장한다.
- `BEFORE_AND_AFTER` 일관성 수준으로 설정된 트랜잭션은 MySQL의 `wait_timeout` 시스템 변수에 설정된 시간까지 대기할 수 있고 대기시간이 초과하는 경우 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다. 



#### 흐름 제어(Flow Control)

- 그룹 복제에서 일부 멤버가 다른 멤버들보다 하드웨어 스펙이 낮거나 네트워크 대역폭이 작고 부하가 심하면 특정 멤버에 트랜잭션이 몰려서 지연될 수 있고 트랜잭션 충돌이 일어날 수 있다.
- 그룹 복제에서는 이처럼 그룹 멤버 간의 트랜잭션 적용 불균형으로 인해 발생하는 문제를 방지하기 위해 그룹 멤버들의 쓰기 처리량을 조절하는 메커니즘이 구현돼 있으며 이를 흐름 제어 라고 한다.
- 그룹 복제에서는 흐름 제어를 통해 멤버 간 트랜잭션 갭을 적게 유지해서 멤버들의 데이터가 최대한 동기화된 상태로 유지될 수 있게 하며, 그룹에 평소와 다른 워크로드가 유입되는 등의 변화에도 빠르게 적응해서 각 멤버들의 쓰기 처리량이 균등하게 할 수 있게 한다. 또한 처리량을 줄이지 않음으로써 서버의 자원이 불필요하게 유휴 상태에 놓여 있지 않게 한다.
- 사용자는 `group_replication_flow_control_mode` 시스템 변수를 통해 멤버에서 흐름 제어 기능의 사용 여부를 설정할 수 있다.
  - `QUOTA` 모드: 해당 변수의 기본 값, 그룹에서 쓰기를 처리하는 멤버가 정해진 할당량만큼만 쓰기를 처리하도록 제어하는 방식
  - `DISABLE` 모드: 흐름제어 동작 X

`QUOTA 모드 흐름 제어 동작 방식`

1. 모든 그룹 멤버들의 쓰기 처리량 및 처리 대기 중인 트랜잭션에 대한 통계를 수집해서 멤버의 처리량을 조절할 필요가 있는지 확인한다.
2. 처리량 조절이 필요한 경우 수집된 통계 데이터를 바탕으로 멤버에게 할당할 쓰기 처리량을 계산한 후 멤버가 계산된 최대 쓰기 처리량을 넘어 쓰기를 처리하지 않도록 멤버의 쓰기 처리를 제한한다.

`흐름 제어에서 수집하는 데이터`

1. 인증(Certification) 큐 크기
2. 적용(Application) 큐 크기
3. 인증된 총 트랜잭션 수
4. 적용된 원격 트랜잭션 수
5. 로컬 트랜잭션 수

<br>

- 통계 정보는 `group_replication_flow_control_period` 시스템 변수에 지정된 시간 마다 수집 및 공유된다. 이 변수는 흐름 제어가 동작하는 주기를 의미한다. 
- `group_replication_flow_control_period` 의 기본값은 매초마다 동작하고 모든 멤버에서 같은 값을 갖는게 좋다.
- 흐름제어에서 수집된 통계 정보 중 인증 큐 크기와 적용 큐 크기를 바탕으로 멤버의 처리량을 조절할 것인지를 판단한다.
- 로컬 멤버를 포함해서 그룹의 모든 멤버들에서 트랜잭션 처리 과정 중 트랜잭션의 충돌을 감지하는 인증 단계와 실제로 트랜잭션을 반영하는 적용 단계에서 얼마나 많은 트랜잭션이 대기하고 있는지를 확인한다.

`흐름제어 임계값 설정`

- `group_replication_flow_control_certifier_threshold`
  - 단위는 트랜잭션 수
  - 인증 큐에서 대기중인 트랜잭션 수가 해당 변수에 지정된 수를 초과하면 흐름 제어가 작동한다
  - 0~2147483647 사이의 값
  - 기본값은 25000
- `group_replication_flow_control_applier_threshold`
  - 단위는 트랜잭션 수
  - 적용 큐에서 대기중인 트랜잭션 수가 해당 변수에 지정된 수를 초과하면 흐름 제어가 작동한다
  - 0~2147483647 사이의 값
  - 기본값은 25000

<br>

- 흐름제어에서는 멤버의 쓰기 처리량을 조절할 필요가 있다고 판단되면 통계 정보를 바탕으로 그룹에서 트랜잭션 적용이 가장 뒤처진 멤버가 처리할 수 있는 수준으로 멤버의 쓰기 처리량을 계산한다.
- 위에서 처리한 값이 멤버에 바로 적용되는 것은 아니고 흐름 제어에서 멤버에게 할당하는 쓰기 처리량과 관련된 시스템 변수들에 사용자가 설정한 값을 참조해서 최종적으로 할당할 쓰기 처리량을 결정하게 된다.

`흐름제어 쓰기 처리량 관련 시스템 변수`

- `group_replication_flow_control_min_quota`
  - 단위는 트랜잭션 수
  - 흐름 제어에서 계산된 쓰기 처리량과 관계없이 멤버에게 할당돼야 하는 최소 쓰기 처리량을 설정한다.
  - 0~2147483647 사이의 값
  - 기본값은 0. 0으로 설정되면 최소 쓰기 처리량제한이 없음을 의미한다.
  - 이 값은 `group_replication_flow_control_max_quota` 값 보다 크게 설정할 수 없다.
- `group_replication_flow_control_min_recovery_quota`
  - 그룹에서 복구 상태의 멤버가 존재하는 경우에 `group_replication_flow_control_min_quota`시스템 변수 대신 적용되는 시스템 변수
  - `group_replication_flow_control_min_quota` 와 나머지는 동일하다.
- `group_replication_flow_control_max_quota`
  - 단위는 트랜잭션 수
  - 흐름 제어에서 그룹에 할당할 수 있는 최대 쓰기 처리량을 설정한다.
  - 0~2147483647 사이의 값
  - 기본값은 0. 0으로 설정되면 최대 쓰기 처리량제한이 없음을 의미한다.
  - 이 값은 `group_replication_flow_control_max_quota`, `group_replication_flow_control_min_recovery_quota` 값 보다 작게 설정할 수 없다.
- `group_replication_flow_control_member_quota_percent`
  - 멤버에게 할당할 쓰기 처리량에서 실제로 얼마 정도의 양을 멤버가 사용하게 할 것인지 백분율을 설정한다.
  - 0~100 사이의 백분율 값
  - 기본값은 0
  - 해당 변수는 멀티 프라이머리 모드에서만 유효하다.
- `group_replication_flow_control_hold_percent`
  - 멤버에게 할당되는 쓰기 처리량에서 사용하지 않고 남겨둘 처리량의 백분율을 설정한다.
  - 0~100 사이의 백분율 값
  - 기본값은 10
- `group_replication_flow_control_release_percent`
  - 흐름 제어에서 더이상 쓰기 멤버에 대해 처리량을 제한할 필요가 없을 때 흐름 제어 주기당 증가시킬 할당량의 백분율을 설정한다.
  - 0~1000 사이의 백분율 값
  - 0으로 설정되면 다음 주기에서 바로 흐름 제어에 의한 처리량 조절이 해제됨을 의미한다.

<br>

`흐름 제어에서 멤버에게 할당할 쓰기 처리량을 계산하는 로직`

1. 통계 정보를 바탕으로 계산된 값과 `group_replication_flow_control_min_quota` 시스템 변수의 값 중 큰 값을 선택한다. 그룹에서 복구중인 멤버가 있다면 `group_replication_flow_control_min_recovery_quota`를 사용한다.
2. 1에서 결정된 값에 100에서 `group_replication_flow_control_hold_percent` 시스템 변수에 설정된 백분율을 뺀 나머지 백분율을 곱한다.
3. `group_replication_flow_control_max_quota` 시스템 변수의 값이 0보다 큰 값으로 설정돼 있는 경우 해당 변수의 값과 2에서 계산된 값 중 더 작은 값을 선택한다.
4. 그룹에서 쓰기를 처리하는 멤버의 수가 둘 이상 존재하는 경우에는 추가적으로 다음과 같이 계산한다
   1. `group_replication_flow_control_member_quota_percent` 시스템 변수에 설정된 값이 0인 경우 3에서 선택된 값을 쓰기 멤버수로 나눈다. (균등하게 처리함을 의미) 쓰기 멤버의 수는 이전 흐름 제어주기에서 쓰기를 수행한 멤버의 수다
   2. `group_replication_flow_control_member_quota_percent` 시스템 변수에 설정된 값이 0이 아닌 경우 3에서 선택된 값에 `group_replication_flow_control_member_quota_percent` 값을 곱한다.

<br>

- 흐름 제어와 관련된 시스템 변수들은 동적으로 변경 가능하며, 그룹 복제를 중단하지 않더라도 변경된 값으로 즉시 반영된다.



### 그룹 복제의 자동 장애 감지 및 대응

- 그룹 복제에서는 그룹의 일부 멤버에 장애가 발생해 응답 불능 상태에 빠졌다 하더라도 그룹이 정상적으로 동작할 수 있게 하는 장애 감지 메커니즘이 구현돼 있다.
- 장애 감지 메커니즘에서는 문제 상태에 있는 멤버를 식별하고 해당 멤버를 그룹 복제에서 제외시킴으로써 그룹이 정상적으로 동작 중인 멤버로만 구성될 수 있게 하고 클라이언트 요청이 문제없이 처리될 수 있게 한다.
- 그룹 복제에서는 멤버 간에 주기적으로 통신 메시지를 주고 받으며 서로의 상태를 확인하는데 멤버로부터 5초 내로 메시지를 받지 못하면 해당 멤버에 문제가 생긴 것으로 의심하기 시작한다.
- 장애가 의심되는 멤버에 대해 과반수의 멤버가 동의하면 해당 멤버를 그룹에서 추방한다.
- MySQL 8.0.13 버전에는 `group_replication_member_expel_timeout` 시스템 변수가 추가되면서 멤버가 의심을 받고 나서 추방되기 전까지의 대기 시간을 초 단위로 지정할 수 있다.
- MySQL 8.0.20 버전에는 해당 기본값이 0이라서 의심되는 즉시 추방되었고 MySQL 8.0.21버전에는 해당 기본값이 5가되어 5초간 대기하고 추방시킨다.
- `group_replication_member_expel_timeout` 시스템변수의 기본값을 그대로 사용할 경우 네트워크가 느린 환경에서는 불필요하게 그룹 멤버가 추방당할 수 있기 때문에 이런 환경에서는 기본값을 좀 더 큰 적절한 값으로 설정하는 것이 좋다.

<br>

- 멤버가 추방되면 그룹 뷰가 변경되므로 그룹 멤버들은 새로운 뷰 ID 값을 갖게 되고 추방된 멤버가 다시 그룹에 재연결하게 되면 자신이 가진 뷰 ID와는 다르기 때문에 자신이 추방됐음을 알게 된다.
- 추방된 멤버는 자동으로 그룹에 재가입을 시도할 수도 있는데 `group_replication_autorejoin_tries` 시스템 변수에 설정된 값에 따라 달라진다. 
- `group_replication_autorejoin_tries` 은 MySQL 8.0.16 버전에서 도입된 변수로 해당 멤버는 해당 그룹에서 추방되면 해당 시스템 변수에 설정된 횟수만큼 그룹에 재가입 시도를 하게 된다.
- `group_replication_autorejoin_tries` 은 MySQL 8.0.20 버전까지 기본값이 0이었고 MySQL 8.0.21 버전부터 기본값이 3으로 변경되었다. 각 시도당 5분의 시간 간격을 둔다.
- 멤버의 재가입 시도에 대한 정보는 `performance_schema` 데이터베이스의 `events_stages_current` 테이블을 통해 확인할 수 있다.

```sql
-- //자동 재가입 프로세스 동작 여부 확인
SELECT COUNT(*)
FROM performance_schema.events_stages_current
WHERE EVENT_NAME LIKE '%auto-rejoin%';

-- //자동 재가입 프로세스 동작 여부 확인
SELECT (WORK_COMPLETE - 1) AS rejoin_num
FROM performance_schema.events_stages_current
WHERE EVENT_NAME LIKE '%auto-rejoin%';

-- //다음 재가입까지 남은 시간
SELECT 
ROUND(360 - ((TIMER_WAIT * 10e-13) - 360 * (WORK_COMPLETED - 1)), 2) AS remaining_seconds
FROM performance_schema.events_stages_current
WHERE EVENT_NAME LIKE '%auto-rejoin%';
```

- 기본적으로 네트워크 단절로 인해 그룹 멤버들이 분리되는 경우 소수에 속하는 멤버들은 스스로 그룹을 탈퇴하지 않는다.
- 사용자는 `group_replication_unreachable_majority_timeout` 시스템 변수를 사용해 소수에 속한 멤버들이 과반수의 그룹 멤버들과 통신이 단절됐을 때 일정 시간 동안 대기한 후 스스로 그룹을 탈퇴하도록 설정할 수 있다.
- `group_replication_unreachable_majority_timeout` 값은 초 단위이고 기본값은 0이다. 0일 경우 그룹을 탈퇴하지 않고 계속 남아있는 것을 의미한다. 최댓값은 1년(31536000)이다
- 소수에 속한 멤버들에서도 트랜잭션을 실행될 수 있지만 실행된 트랜잭션은 멤버가 그룹의 과반수의 동의를 얻을 수 없으므로 처리가 보류된 상태로 남아있게 된다.
- `group_replication_unreachable_majority_timeout` 값이 도달하면 멤버는 보류 상태의 모든 트랜잭션을 롤백하고 그룹에서 탈퇴하며 상태는 ERROR 로 표기된다. 
- 만약 `group_replication_autorejoin_tries` 값이 0이 아니라면 멤버는 이 시점에 그룹 재가입을 시도한다.
- 그룹의 멤버가 둘 또는 넷처럼 대칭 형태의 그룹이라면 네트워크 단절로 인해 같은 수의 멤버로 그룹이 분리되면 모든 멤버들은 자신이 소수 그룹에 속하는 것으로 간주하고 `group_replication_unreachable_majority_timeout` 값 만큼 대기 후 탈퇴하므로 이부분을 반드시 고려해야 한다.
- 멤버가 그룹의 다른 멤버들과 통신 단절 등의 문제로 인해 타의 혹은 자의로 그룹에서 탈퇴한 상태에서 자동 재가입에 실패하거나 혹은 재가입을 시도하지 않게 설정된 경우 멤버는 최종적으로 `group_replicawtion_exit_state_action` 시스템 변수에 설정된 작업을 진행하게 된다. 이를 종료 액션이라고 하고 MySQL 8.0.12 버전부터 사용 가능하다.

`group_replicawtion_exit_state_action 종류`

- `READ_ONLY`
  - `super_read_only` 시스템 변수를 ON 으로 설정해서 MySQL 서버를 슈퍼 읽기 전용 모드로 전환시킨다.
  - 슈퍼 읽기 전용 모드에서 사용자가 `CONNECTION_ADMIN` 권한을 가지고 있더라고 하더라도 데이터 변경 작업을 수행할 수 없다.
  - MySQL 8.0.16 버전부터 해당 값이 이 값으로 기본 설정 됐다.
  - 또한 이 값은 `group_replicawtion_exit_state_action` 시스템 변수가 도입되기 전에 MySQL 8.0에서 수행했던 방식이기도 하다.
- `ONFFLINE_MODE`
  - `offline_mode` 시스템 변수를 ON 으로 설정해서 MySQL 서버를 오프라인 모드로 전환시키고 `super_read_only` 시스템 변수도 ON으로 설정한다.
  - 오프라인 모드에서는 기존에 이미 연결돼 있는 세션의 경우 다음 요청에서 연결이 끊어지고 `CONNECTION_ADMIN` 권한을 가진 사용자를 제외하고 더이상 연결이 되지 않는다.
  - 이 값은 MySQL 8.0.18 버전부터 설정할 수 있다.
- `ABORT_SERVER`
  - MySQL 서버를 종료시킨다.
  - `group_replicawtion_exit_state_action` 시스템 변수가 도입된 MySQL 8.0.12 버전부터 8.0.15버전까지 해당 값이 기본값이었다.

<br>

`group_replicawtion_exit_state_action 발생 시점`

- 그룹 복제의 어플라이어 스레드에 에러가 발생한 경우
- 멤버가 그룹 복제의 분산 복구 프로세스를 정상적으로 완료할 수 없는 경우
- `group_replication_switch_to_single_primary_mode()` 같은 그룹 복제 UDF를 사용해 그룹 전체에 대한 설정을 변경하는 중에 에러가 발생한 경우
- 싱글 프라이머리 모드 그룹에서 새 프라이머리 선출 과정 중 에러가 발생한 경우
- 과반수 이상의 다른 그룹 멤버들과 통신이 단절되고 `group_replication_unreachable_majority_timeout` 시스템 변수에 설정된 대기 시간이 초과됐으나 그룹에 재가입 시도를 하지 않도록 설정된 경우
- 멤버에 문제가 발생해서 `group_replication_member_expel_timeout` 시스템 변수에 설정된 대기 시간이 초과된 후 그룹에서 추방되고 나서 다시 그룹의 다른 멤버들과 통신이 재개되어 자신이 추방됐음을 확인 했으나 그룹에 재가입 시도를 하지 않도록 설정된 경우
- 멤버가 자의 혹은 타의로 그룹에서 탈퇴한 후 `group_replication_autorejoin_tries` 시스템 변수에 지정된 횟수 동안 그룹에 재가입을 성공하지 못한 경우

### 그룹 복제의 분산 복구

- 멤버가 그룹에 새로 가입하거나 혹은 탈퇴 후 다시 가입할 때, 가입하기 전 또는 잠시 그룹을 떠나있는 동안 그룹에 적용된 트랜잭션들이 있을 수 있다. 멤버는 이러한 트랜잭션들을 모두 적용해야 다른 그룹 멤버들이 가진 데이터와 동일한 데이터를 갖게 되고 그 때 그룹에 정상적으로 참여할 수 있다.
- 그룹 복제에서는 그룹 가입 시 가입 멤버가 다른 그룹 멤버들과 동일한 최신 데이터를 가질 수 있도록 가입 멤버에서 누락된 트랜잭션들을 다른 그룹 멤버에서 가져와 적용하는 복구 프로세스를 자동으로 수행하게 되는데 이를 분산 복구라고 한다.
- 분산 복구에서 가입 멤버가 복구 작업을 위해 선택한 기존 그룹 멤버를 기증자(Donor) 멤버라고 하고 그룹에서 온라인 상태로 존재하는 모든 멤버들은 기증자 멤버가 될 수 있다.

#### 분산 복구 방식

- 그룹 복제의 분산 복구에서는 복구 작업 시 먼저 가입 멤버에서 `group_replication_applier` 복제 채널의 릴레이 로그를 먼저 확인하고 미처 적용되지 못하고 남아있는 트랜잭션이 있는지 확인한다. 만약 발견된경우 이 트랜잭션을 먼저 적용하는 것으로 복구 작업을 시작한다.
- 가입한 멤버의 릴레이로그를 확인한 이후 그룹에 온라인 상태로 존재하는 다른 그룹 멤버에 연결해서 분산 복구 작업을 마저 진행하는데 아래 두 가지 방법을 적절히 조합해서 분산 복구 작업을 진행한다.

`바이너리 로그 복제 방식`

- 바이너리 로그 복제 방식은 MySQL의 기본 복제 방식인 비동기 복제를 기반으로 구현됐다.
- 기증자로 선택된 다른 그룹 멤버와 `group_replication_recovery` 라는 별도의 복제 채널로 연결되어 해당 멤버의 바이너리 로그에서 가입한 멤버에 적용되지 않은 트랜잭션들을 복제해서 가져와 가입한 멤버에 적용하는 방식이다.

`원격 클론(Remote Cloning) 방식`

- 원격 클론 방식은 MySQL 8.0.17에 도입된 클론 플러그인을 사용하는 형태다.
- 다른 그룹 멤버의 InnoDB 스토리지 엔진에 저장된 모든 데이터와 메타데이터를 일관된 스냅숏으로 가져와 가입 멤버를 재구축하는 방식이다.
- 이방식으로 복구 작업을 진행하려면 그룹 멤버들과 가입 멤버 모두 클론 플러그인이 설치되어 있어야 한다.
- 원 격 클론 방식에서는 가입한 멤버의 기존 데이터는 모두 제거되고 클론 작업으로 연결된 기존 그룹 멤버의 스냅숏 데이터로 대체된다.

<br><br>

- 그룹 복제의 분산 복구에서는 가입한 멤버에 대해 가장 적합한 형태의 복구 방식을 자동으로 선택한다.
- 가입한 멤버와 기존 그룹 멤버 간의 트랜잭션 갭이 크거나 혹은 필요한 트랜잭션들 중 일부가 기존 그룹 멤버의 바이너리 로그 파일에 더이상 존재하지 않는 경우 분산 복구에서는 원격 클론 방식으로 복구 작업을 시작한다.
- 만약 트랜잭션 갭이 크지 않거나 클론 플러그인이 설치되어 있지 않은 경우 바이너리 로그 복제 방식으로만 진행한다.
- 분산 복구에서 원격 클론 방식을 복구 방식으로 채택하게 되는 트랜잭션 갭의 임계값은 `group_replication_clone_threshold` 시스템 변수에 지정된 값을 사용한다.
- `group_replication_clone_threshold` 의 기본값은 아주 큰 값이므로 바이너리 로그 복제 방식이 가능한 환경에서는 원격 클론 방식이 분산 복구에 사용되지 않는다. 따라서 필요하다면 적절하게 조정해야 한다

>  default value = 9223372036854775807 ;;; [https://dev.mysql.com/doc/refman/8.0/en/group-replication-options.html#sysvar_group_replication_clone_threshold](https://dev.mysql.com/doc/refman/8.0/en/group-replication-options.html#sysvar_group_replication_clone_threshold)

- `group_replication_clone_threshold` 만큼의 트랜잭션 갭이 발생하지 않더라도 바이너리 로그 복제 방식이 사용 불가능하다면 원격 클론 방식으로 복구 작업을 진행한다.
- `group_replication_clone_threshold` 값을 너무 낮은 값으로 적용하면 분산 복구가 진행될 동안에 트랜잭션 그룹에 적용된 트랜잭션 수가 다시 `group_replication_clone_threshold` 만큼 쌓이게 되면 계속 분산 복구를 진행할 수 있기 때문에 원격 클론 작업이 진행되는 동안 그룹에서 발생할 것으로 예상되는 트랜잭션 수보다 높게 설정해야 한다.



#### 분산 복구 프로세스

`그룹 복제에서 수행되는 분산 복구 작업 순서`

`1.로컬 복구`

- 가입 멤버가 이전에 그룹에 가입한 적이 있는 경우 릴레이 로그에 미처 적용하지 못한 트랜잭션이 존재할 수 있다.
- 따라서 이 트랜잭션들을 먼저 적용한 후 본격적인 복구 작업을 진행한다.

`2.글로벌 복구`

- 가입 멤버는 그룹의 기존 멤버들에서 기증자 역할을 할 멤버를 선택해서 해당 멤버로부터 데이터 또는 누락된 트랜잭션들을 가져와 자신에게 적용한다.
- 이 작업을 진행하는 동안 형제 그룹에서 처리되는 트랜잭션들을 내부적으로 캐싱해둔다.

`3.캐시 트랜잭션 적용`

- 글로벌 복구 단계가 완료되면 캐싱해서 보관하고 있던 트랜잭션들을 적용해 최종적으로 그룹에 참여한다.

<br><br>

- 새로운 멤버가 그룹에 가입하면 가입 멤버는 분산 복구 프로세스를 진행한다.
- 1차적으로 로컬 복구가 완료되면 본격적인 복구 작업을 위해 그룹 내 온라인 상태로 존재하는 멤버들 중 기증자 멤버를 무작위로 선정하고 적절한 복구 방식(바이너리 or 원격 클론 방식)을 선택해 복구 작업을 시작한다.
- 원격 클론 방식에서 가입 멤버는 기증자 멤버의 스냅숏 데이터를 모두 전달받으면 MySQL 서버를 재시작한다. 이때 `group_replication_start_on_boot=ON` 옵션이 설정되어 있는 경우 MySQL 서버가 재시작할 때 그룹 복제가 자동으로 시작되고 바이너리 로그 복제 방식의 분산 복구가 시작된다. 만약 이 옵션이 OFF라면 사용자가 수동으로 `START GROUP_REPLICATION` 명령을 시작해야 한다.
- 바이너리 로그 복제 복구 방식에서는 가입 멤버가 그룹에 참여한 시점까지만 복구 작업을 진행하며, 가입 멤버는 복구 작업동안 그룹에서 처리된 트랜잭션을 캐싱한다.
- 가입 멤버가 그룹에 참여한 시점은 뷰 변경 로그 이벤트를 통해 알 수 있다. 따라서 바이너리 로그 복제 방식에서는 기증자 멤버에서 누락된 트랜잭션들을 가져와서 적용하다가 가입 멤버가 그룹에 참여했을 때 해당되는 뷰 변경 로그 이벤트를 만나면 복제를 중지하고 캐싱된 트랜잭션을 적용하는 것으로 전환한다.



#### 분산 복구 설정

- 사용자는 그룹 복제의 분산 복구에서 다음과 같은 부분들을 필요에 맞게 설정할 수 있다.

`연결 시도 횟수`

- 사용자는 `group_replication_recovery_retry_count` 시스템 변수를 통해 바이너리 로그 복제 방식으로 복구 작업 진행 시 가입한 멤버가 기존 그룹 멤버에 연결을 시도하는 횟수를 제한할 수 있다.
- 만약 그룹에서 두 멤버가 적절한 연결 후보 멤버이고 연결 시도 제한 횟수가 6이라면 가입한 멤버는 각 연결 후보 멤버들로 최대 3번까지 연결 시도를 한다.
- 지정한 횟수동안 연결에 성공하지 못한다면 분산 복구 프로세스는 에러를 출력하고 종료된다.
- `group_replication_recovery_retry_count` 시스템변수의 기본 값은 10이고 최대 31536000 까지 설정 가능하다.

`연결 시도 간격`

- 사용자는 `group_replication_recovery_reconnect_interval` 시스템 변수를 통해 바이너리 로그 복제 방식으로 복구 작업을 진행할 때 기존 그룹 멤버들에 대한 연결 시도 사이의 대기 시간을 지정할 수 있다.
- 분산 복구에서는 각 그룹 멤버에 연결을 시도할 때마다 이 대기 시간을 가지는 것은 아니며, 연결 대상 멤버에 대해 한 번씩 전부 연결을 시도하고 나서 `group_replication_recovery_reconnect_interval` 시스템 변수에 지정된 시간만큼 대기하게 된다.
- `group_replication_recovery_retry_count` 은 초 단위이고 기본값은 60초다.

`가입한 멤버를 온라인 상태로 표기하는 시점`

- 기본적으로 가입한 멤버에서 분산 복구가 완료되면 멤버의 상태가 ONLINE으로 표시된다.
- 가입한 멤버에서 누락된 트랜잭션들이 인증 단계까지 모두 완료했을 때 그룹 뷰에서 가입한 멤버의 상태를 ONLINE으로 표시되도록 설정할 수도 있으며 이는 `group_replication_recovery_complete_at` 시스템 변수의 값을 `TRANSACTIONS_CERTIFIED`로 설정하면 된다.
- 해당 변수의 기본 값은 `TRANSACTIONS_APPLIED` 로 앞서 설명한 바와 같이 누락된 트랜잭션들이 모두 적용된 시점에 멤버의 상태를 ONLINE으로 표시하게 된다.

<br><br>

- 위에서 설명한 값 모두 그룹 복제가 실행되는 동안 변경할 수 있지만 변경된 값은 멤버에서 그룹 복제를 중지하고 다시 시작한 후에만 실제로 적용된다.

#### 분산 복구 오류 처리

- 그룹 복제의 분산 복구에는 복구 작업 도중 문제가 발생하더라도 가능한 경우 자동으로 작업을 다시 시도하는 장애 감지 메커니즘이 구현돼 있다. 다음과 같은 경우들에서 분산 복구는 자동으로 새로운 그룹 멤버로 연결을 전환해서 다시 작업을 시도한다
  - 기증자로 선택한 그룹 멤버로의 연결이 인증 문제 등으로 인해 정상적으로 이뤄지지 않는 경우
  - 바이너리 로그 복제 방식으로 복구 작업을 진행하는 중에 레플리케이션 I/O 스레드 또는 SQL 스레드에서 에러가 발생한 경우
  - 원격 클론 작업이 실패하거나 혹은 완료되기 전에 중단된 경우
  - 복구 작업 동안 기증자 멤버에서 그룹 복제가 중단된 경우
- 사용자는 `performance_schema`의 `replication_connection_status` 테이블 또는 `replication_applier_status_by_worker` 테이블에서 "LAST_ERROR_"로 시작하는 칼럼들로부터 바이너리 로그 복제 방식의 분산 복구와 관련해서 가장 최근에 발생한 에러를 확인할 수 있다.
- 원격 클론 방식의 분산 복구 작업의 경우 `performance_schema`의 `clone_progress` 및 `clone_status` 테이블을 통해 클론 작업의 진행 현황과 상태 정보를 확인할 수 있다.

```sql
SELECT CHANNEL_NAME,
    LAST_ERROR_NUMBER,
    LAST_ERROR_MESSAGE,
    LAST_ERROR_TIMESTAMP
	FROM performance_schema.replication_connection_status
	WHERE CHANNEL_NAME='group_replication_recovery' \G
```

- 다음과 같은 경우 분산 복구 프로세스가 더이상 진행될 수 없으며 가입 멤버는 그룹을 떠나게 된다.
  - 가입 멤버가 `group_replication_recovery_retry_count` 시스템 변수에 지정된 재시도 횟수를 모두 소진한 경우
  - 가입 멤버에 필요한 트랜잭션이 그룹 멤버들의 바이너리 로그에 존재하지 않으며, 원격 클론 방식으로도 복구 작업을 진행할 수 없는 경우
  - 가입 멤버가 그룹에서는 존재하지 않는 트랜잭션을 가지고 있는 상태에서 바이너리 로그 복제 방식으로 복구 작업이 진행되는 경우
  - 가입 멤버가 전체 그룹 멤버에 대해 원격 클론 방식과 바이너리 로그 복제 방식을 모두 시도해봤지만 전부 실패해서 더이상 시도해 볼 멤버가 존재하지 않는 경우
  - 복구 작업이 진행되는 중에 가입 멤버에서 그룹 복제가 중단된 경우
- 가입 멤버가 복구 작업중에 직접 그룹을 탈퇴한 경우를 제외한 나머지의 경우에서 가입 멤버는 최종적으로 `group_replication_exist_state_action` 시스템 변수에 지정된 작업을 수행한다.



### 그룹 복제 요구사항

- 그룹 복제를 사용하려는  MySQL 서버에서는 다음 요구사항들을 충족해야 한다.

`InnoDB 스토리지 엔진 사용`

- 데이터가 저장되는 테이블은 방드시 InnoDB 스토리지 엔진을 사용해야 한다. (트랜잭션을 지원하는 엔진이 필요하기 때문에)
- 다른 스토리지 엔진을 사용할 경우 그룹 복제에서 에러가 발생할 수 있다. 따라서 MySQL 설정 파일에 `disabled_storage_engines` 시스템 변수를 설정해서 다른 스토리지 엔진의 사용을 방지할 수 있다.

```
[mysqld]
disabled_storage_engines="MyISAM,BALCKHOLE,FEDERATED,ARCHIVE,MEMORY"
```

`프라이머리 키 사용`

- 그룹에서 복제될 모든 테이블들은 프라이머리 키를 갖고 있어야하고 명시적인 프라이머리 키가 없다면 NULL값을 허용하지 않는 유니크 키가 테이블에 반드시 존재해야 한다.
- 이러한 키들은 모든 데이터에 대해 고유한 식별자 역할을 하고 그룹 복제에서는 이를 바탕으로 트랜잭션 간 충돌을 방지한다.

`원활한 네트워크 통신 환경`

- 그룹 복제는 그룹 멤버들 간의 양방향 통신을 통해 이뤄지므로 그룹 복제의 성능과 안전성은 서버가 속한 네트워크 환경에 영향을 받는다.

`바이너리 로그 활성화`

- 그룹 복제는 기본 MySQL 복제와 마찬가지로 복제에서 바이너리 로그를 사용하므로 서버에서 바아니러 로그가 활성화되어 있어야 한다.
- MySQL 8.0부터 바이너리 로그는 기본적으로 활성화 된다.

`ROW 형태의 바이너리 로그 포맷 사용`

- 그룹 복제는 ROW 포맷 기반의 복제를 사용해 트랜잭션으로 인해 변경된 데이터가 그룹 멤버들에서 일관되게 적용될 수 있게 한다.

`바이너리 로그 체크섬 설정`

- MySQL 8.0.20 버전까지는 그룹 복제에서 바이너리 로그 체크섬 기능을 지원하지 않으므로 `binlog_checksum` 시스템 변수의 값을 `NONE` 으로 설정해야 한다.
- MySQL 8.0.21 버전부터는 체크섬 기능을 지원하므로 해당 변수에 사용자가 원하는 값을 설정할 수 있다.

`logslave_updates 활성화`

- 새로운 멤버가 그룹에 참여하면 해당 멤버는 기존 그룹 멤버들과 동일하게 그룹의 최신 데이터를 가질 수 있도록 그룹 복제의 분산 복구 작업을 수행하는데, 이때 기존 그룹 멤버의 바이너리 로그를 복제해서 자신에게 적용하므로 그룹 멤버들은 그룹에서 발생한 트랜잭션들을 모두 각자의 바이너리 로그에 기록해야 한다.
- 또한 그룹 복제에서 그룹의 모든 멤버들이 쓰기를 수행하는 프라이머리 서버가 될 수 있으므로 그룹 복제를 설정할 MySQL 서버에서는 `log_slave_updates` 시스템 변수가 반드시 활성화돼 있어야 한다.

`GTID 사용`

- 그룹 복제는 기본적으로 GTID를 사용하므로 그룹 복제에 설정할 MySQL 서버는 GTID가 활성화 될 수 있또록 설정 파일에 다음과 같이 옵션을 설정해야 한다.

```
[mysqld]
dtid_mode=ON
enforce_gtid_consistency=ON
```

`고유한 server_id 값 사용`

- 그룹 복제에 참여하는 MySQL 서버들은 모두 각기 다른 고유한 `server_id` 값을 가져야 한다.

`복제 메타데이터 저장소 설정`

- 그룹 복제에서 복제 관련 메타디에터는 데이터는 일관성을 위해 파일이 아닌 테이블에 저장돼야 한다.
- 따라서 MySQL 서버에서 `master_info_repository` 및 `replay_log_info_repository` 시스템 변수의 값이 `TABLE`로 설정돼 있어야 한다.

`트랜잭션 WriteSet 설정`

- 트랜잭션에서 변경한 데이터에 대한 정보, 즉 트랜잭션이 WriteSet이 수집될 수 있또록 `transaction_write_set_extraction` 시스템 변수가 `XXHASH64`로 설정돼야 한다. 트랜잭션의 WriteSet은 그룹 복제에서 트랜잭션 간 충돌을 탐지하는 트랜잭션 인증 단계에서 사용된다.

`테이블 스페이스 암호화 설정`

- `default_talbe_encryption` 시스템 변수는 모든 그룹 멤버에 동일한 값으로 설정돼야 한다.

`lower_case_table_names 설정`

- `lower_case_table_names` 시스템 변수는 모든 그룹 멤버에서 동일한 값으로 설정돼야 한다.

`멀티 스레드 복제 설정`

- 그룹 복제에서도 멀티 스레드 복제 기능을 사용해 트랜잭션을 병렬로 적용할 수 있다.

```
[mysqld]
salve_parallel_workers=N
slave_parallel_tpye=LOGICAL_CLOCK
slave_preserve_commit_order=1
```



### 그룹 복제 제약 사항

`그룹 복제 제약 사항`

- 갭 락은 갭 락을 발생시킨 트랜잭션이 실행된 멤버에서만 유효하며, 그룹 복제의 트랜잭션 인증 단계에서 해당 락 정보는 공유되지 않는다. 따라서 갭락이 사용되지 않는 `READ-COMMITED` 트랜잭션 격리수준을 사용하는 것이 좋다.

- 테이블락 및 네임드락도 그룹단위로 락 정보가 공유되지 않는다. 그룹 복제의 인증 단계에서는 이 두 락을 고려하지 않는다.

- 그룹 복제에서 바이너리 로그 체크섬 기능은 MySQL 8.0.21 버전부터 사용 가능하며 그 이전 버전에서는 지원하지 않는다.

- 멀티 프라이머리 모드로 동작중인 그룹에서는 `SERIALIZABLE` 트랜잭션 격리수준을 사용할 수 없다.

- 멀티 프라이머리 모드로 동작중인 그룹에서 동일한 테이블에 대해 서로 다른 멤버에서 동시에 실행되는 DDL 및 DML 문은 지원하지 않는다.

- 멀티 프라이머리로 동작 중인 그룹에서 외래키가 존재하는 테이블, 특히 `CASCADE` 제약 조건이 사용된 테이블은 지원하지 않는다. `CASCADE` 제약 조건으로 그룹 멤버 간에 데이터가 일치하지 않을 수 있다. 이를 위해 `group_replication_enforce_update_everywhare_checks` 시스템 변수가 활성화되면 그룹 복제에서는 실행된 쿼리에 대해 멀티 프라이머리 모드와 호환 가능하능한지를 검사하게 할 수 있다. 싱글 프라이머리 모드에서는 데이터 일관성을 해칠 수 있는 문제는 발생하지 않으므로 해당 시스템변수는 비활성화해서 사용해야 한다.

- 멀티 프라이머리 모드에서 `SELECT ... FOR UPDATE` 구문을 사용할 때 데드락이 발생할 수 있다.

- 그룹 복제에서 복제 필터 기능은 사용할 수 없다. 그룹 멤버가 그룹 복제와 더불어 그룹 외부의 다른 소스 서버에 대한 일반 복제도 함께 진행하는 경우 일반 복제에 대한 필터링은 설정할 수 있다.

- 그룹 복제는 최대 9대의 서버까지 구성 가능하다. 이미 9대로 구성된 그룹 복제에서 새로 멤버가 추가되는 경우에는 에러가 발생한다.

  



## MySQL 셸

- MySQL 셸은 MySQL을 위한 고급 클라이언트 툴로, 단순히 SQL문 실행만 가능했던 기존 클라이언트 툴인 mysql 보다 좀 더 확장된 기능들을 사용자에게 제공한다.
- MySQL 셸은 SQL뿐만 아니라 자바스크립트와 파이썬 모드도 제공한다.

```
//js 모드 전환
 MySQL  localhost:3301 ssl  SQL > \js
Switching to JavaScript mode...

//python 모드 전환
 MySQL  localhost:3301 ssl  JS > \py
Switching to Python mode...

//sql 모드 전환
 MySQL  localhost:3301 ssl  Py > \sql
Switching to SQL mode... Commands end with ;

```

- MySQL 셸은 아래와 같은 API도 제공한다.
  - X 프로토콜을 사용해 MySQL 서버에서 관계형 데이터와 문서 기반 데이터를 모두 처리할 수 있게 하는 X DevAPI
  - MySQL 서버의 설정을 변경하고 InnoDB 클러스터 및 InnoDB 레플리카셋을 구축할 수 있게 하는 Admin API
- MySQL 셸에 내장돼 있는 글로벌 객체들과 각 객체에 구현돼 있는 메서드를 통해 API를 사용할 수 있다.
- MySQL 셸의 글로벌 객체는 자바스크립트모드, 파이썬 모드에서만 사용할 수 있다.

`MySQL 셸의 글로벌 객체`

- `session`
  - 셸에서 MySQL 서버에 연결했을 때 생성된 세션에 매핑되는 객체
  - 트랜잭션 시작과 같이 세션 단위에서 사용할 수 있는 기능들을 제공한다.
- `dba`
  - InnoDB 클러스터 및 InnoDB 레플리카셋 구축과 관련된 기능을 제공하며, 내부적으로 AdminAPI를 사용해 처리한다.
- `cluster`
  - InnoDB 클러스터에 매핑되는 객체
  - 클러스터 설정 변경 등과 같이 클러스터와 관련해서 사용자가 제어할 수 있는 기능들을 제공한다.
- `rs`
  - InnoDB 레플리카셋에 매핑되는 객체
  - 레플리카셋 설정 변경 등과 같이 레플리카셋과 관련해서 사용자가 제어할 수 있는 기능들을 제공한다.
- `db`
  - 셸에서 X 프로토콜을 사용해 MySQL 서버에 연결한 경우 연결 시 지정했던 데이터베이스에 매핑되는 객체
  - 데이터베이스와 관련해서 사용할 수 있는 기능들을 제공한다.
- `shell`
  - MySQL 셸 설정 변경 등과 같이 셸과 관련ㄹ해서 사용자가 제어할 수 있는 기능들을 제공한다.
- `utill`
  - MySQL 서버가 버전을 업그레이드할 준비가 됐는지 확인하거나 MySQL 서버에 데이터를 로딩 또는 추출하는 등의 유용한 작업 기능들을 제공한다.



## MySQL 라우터

- MySQL 라우터는 InnoDB 클러스터에서 애플리케이션 서버로 유입된 쿼리 요청을 클러스터 내 적절한 MySQL 서버로 전달하고 MySQL 서버에서 반환된 쿼리 결과를 다시 애플리케이션 서버로 전달하는 proxy 역할을 수행한다.
- MySQL 라우터의 중요 기능
  - InnoDB 클러스터의 MySQL 구성 변경 자동 감지
  - 쿼리 부하 분산
  - 자동 페일 오버
- MySQL 라우터는 클러스터 내 MySQL 서버들에 대한 정보를 메모리에 캐시하고 있고 주기적으로 이 정보를 갱신한다. 따라서 MySQL 라우터를 사용하는 애플리케이션은 MySQL 서버의 커넥션 설정 정보를 직접 변경할 일이 없다.
- MySQL 라우터는 부하 분산도 지원하는데 사용자는 MySQL 라우터의 부하 분산 방식을 지정할 수 있다.
- MySQL 라우터는 MySQL 서버에 장애가 발생한 경우 자동으로 다른 MySQL 서버로 쿼리를 재시도하는데 이때 지정된 부하 분산 방식에 따라 재시도할 MySQL 서버를 결정하게 할 수 있다.



## InnoDB 클러스터 구축

### InnoDB 클러스터 요구사항

- InnoDB 클러스터를 구헝하는 각 구성 요소들은 최소한 다음과 같은 버전으로 설치 되어야 한다.
  - MySQL 서버 5.7.17 이상
  - MySQL 셸 1.0.8 이상
  - MySQL 라우터 2.1.2 이상
- InnoDB 클러스터의 MySQL 서버들은 모두 Performance 스키마가 활성화 돼있어야 한다.
- MySQL 셸을 사용해 InnoDB 클러스터를 구성하기 위해 MySQL 셸이 설치될 서버에 파이썬 2.7이상의 버전으로 설치돼 있어야 한다.

> innodb-cluster docker-compose github
>
> - [https://github.com/neumayer/mysql-docker-compose-examples](https://github.com/neumayer/mysql-docker-compose-examples)



### InnoDB 클러스터 생성                                                                                                                                                                                                                                                                                                                                   

### 사전 준비

- InnoDB 클러스터에 사용될 MySQL 서버들은 InnoDB 클러스터 요구사항을 충족하도록 서버 옵션들이 적절하게 설정되어 있어야한다. MySQL 셸을 이용해서 간단하고 편리하게 설정할 수 있다.

```
MySQL  localhost:33060+ ssl  JS > dba.configureInstance("root@localhost:3306")
Configuring local MySQL instance listening at port 3306 for use in an InnoDB cluster...

This instance reports its own address as A10300ui-MacBookPro.local:3306
Clients and other cluster members will communicate with it through this address by default. If this is not correct, the report_host MySQL system variable should be changed.

ERROR: User 'root' can only connect from 'localhost'. New account(s) with proper source address specification to allow remote connection from all instances must be created to manage the cluster.

1) Create remotely usable account for 'root' with same grants and password
2) Create a new admin account for InnoDB cluster with minimal required grants
3) Ignore and continue
4) Cancel

Please select an option [1]: 2
Please provide an account name (e.g: icroot@%) to have it created with the necessary
privileges or leave empty and press Enter to cancel.
Account Name: icadmin@%
Password for new account: 
Confirm password: 

applierWorkerThreads will be set to the default value of 4.

NOTE: Some configuration options need to be fixed:
+----------------------------------------+---------------+----------------+--------------------------------------------------+
| Variable                               | Current Value | Required Value | Note                                             |
+----------------------------------------+---------------+----------------+--------------------------------------------------+
| binlog_transaction_dependency_tracking | COMMIT_ORDER  | WRITESET       | Update the server variable                       |
| enforce_gtid_consistency               | OFF           | ON             | Update read-only variable and restart the server |
| gtid_mode                              | OFF           | ON             | Update read-only variable and restart the server |
| server_id                              | 1             | <unique ID>    | Update read-only variable and restart the server |
+----------------------------------------+---------------+----------------+--------------------------------------------------+

Some variables need to be changed, but cannot be done dynamically on the server.
Do you want to perform the required configuration changes? [y/n]: y
Do you want to restart the instance after configuring it? [y/n]: y

Cluster admin user 'icadmin'@'%' created.
Configuring instance...
The instance 'A10300ui-MacBookPro.local:3306' was configured to be used in an InnoDB cluster.
Restarting MySQL...
NOTE: MySQL server at A10300ui-MacBookPro.local:3306 was restarted.

```

- `dba.configureInstance("root@localhost:3306")` 구문을 사용해서 현재 설정이 InnoDB 클러스터에 요구되는 사항들을 충족하는지 확인하고 필요 시 자동으로 서버를 재설정 한다.
- 위와 같이 새로 계정을 생성할 수 있다.
  - icadmin2@%:qwer!23





#### InnoDB 클러스터 생성

```
//mysql 서버로 접속
MySQL  JS > \connect icadmin@localhost:3306
Creating a session to 'icadmin@localhost:3306'

//클러스터 생성
MySQL  localhost:3301 ssl  JS > var cluster = dba.createCluster("testCluster");

A new InnoDB cluster will be created on instance 'localhost:3306'.

Validating instance configuration at localhost:3306...

This instance reports its own address as A10300ui-MacBookPro.local:3306

Instance configuration is suitable.
NOTE: Group Replication will communicate with other members using 'A10300ui-MacBookPro.local:33061'. Use the localAddress option to override.

Creating InnoDB cluster 'testCluster' on 'A10300ui-MacBookPro.local:3306'...

Adding Seed Instance...
Cluster successfully created. Use Cluster.addInstance() to add MySQL instances.
At least 3 instances are needed for the cluster to be able to withstand up to
one server failure.
 
```

- 복잡한 그룹 복제 설정없이 클러스터 생성을 `dba.createCluster()` 처럼 쉽게 사용할 수 있다.
- `dba.createCluster()` 에서 수행되는 일
  - InnoDB 클러스터에 대한 정보를 저장할 메타데이터 데이터베이스 (mysql_innodb_cluster_metadata 생성) 및 메타데이터 설정
  - 그룹 복제 설정 및 시작
  - 그룹 복제 분산 복구에서 사용될 db 계정 생성
- InnoDB 클러스터는 기본적으로 싱글 프라이머리 모드로 생성되며 처음 클러스터 생성을 진행한 MySQL 서버가 프라이머리로 지정된다.
- 만약 멀티 프라이머리로 클러스터를 생성하고 싶다면 아래와 같은 옵션을 지정해야 한다.

```javascript
var cluster = dba.createCluster("testCluster", {multiPrimary:true})
```

- 클러스터 상태 조회와 같은 클러스터 관련 명령들은 클러스터 객체를 통해 실행할 수 있다.

```javascript
var cluster = dba.getCluster()
cluster.status()

{
    "clusterName": "devCluster", 
    "defaultReplicaSet": {
        "name": "default", 
        "primary": "mysql-server-1:3306", 
        "ssl": "REQUIRED", 
        "status": "OK", 
        "statusText": "Cluster is ONLINE and can tolerate up to ONE failure.", 
        "topology": {
            "mysql-server-1:3306": {
                "address": "mysql-server-1:3306", 
                "instanceErrors": [
                    "NOTE: instance server_id is not registered in the metadata. Use cluster.rescan() to update the metadata."
                ], 
                "memberRole": "PRIMARY", 
                "memberState": "(MISSING)", 
                "mode": "n/a", 
                "readReplicas": {}, 
                "role": "HA", 
                "shellConnectError": "MySQL Error 2005: Could not open connection to 'mysql-server-1:3306': Unknown MySQL server host 'mysql-server-1' (8)", 
                "status": "ONLINE", 
                "version": "8.0.12"
            }, 
            "mysql-server-2:3306": {
                "address": "mysql-server-2:3306", 
                "instanceErrors": [
                    "NOTE: instance server_id is not registered in the metadata. Use cluster.rescan() to update the metadata."
                ], 
                "memberRole": "SECONDARY", 
                "memberState": "(MISSING)", 
                "mode": "n/a", 
                "readReplicas": {}, 
                "role": "HA", 
                "shellConnectError": "MySQL Error 2005: Could not open connection to 'mysql-server-2:3306': Unknown MySQL server host 'mysql-server-2' (8)", 
                "status": "ONLINE", 
                "version": "8.0.12"
            }, 
            "mysql-server-3:3306": {
                "address": "mysql-server-3:3306", 
                "instanceErrors": [
                    "NOTE: instance server_id is not registered in the metadata. Use cluster.rescan() to update the metadata."
                ], 
                "memberRole": "SECONDARY", 
                "memberState": "(MISSING)", 
                "mode": "n/a", 
                "readReplicas": {}, 
                "role": "HA", 
                "shellConnectError": "MySQL Error 2005: Could not open connection to 'mysql-server-3:3306': Unknown MySQL server host 'mysql-server-3' (8)", 
                "status": "ONLINE", 
                "version": "8.0.12"
            }
        }, 
        "topologyMode": "Single-Primary"
    }, 
    "groupInformationSourceMember": "30f50168f043:3306"
}

```



#### InnoDB 클러스터 인스턴스 추가

- 클러스터에 서버를 추가하려면 `<Cluster>.addInstance()` 메서드를 사용하면 된다.
- 클러스터의 추가는 프라이머리가 아니여도 가능하다

```
var cluster = dba.getCluster()
cluster.addInstance("root@localhost:3302")
```

- 만약 클러스터의 대상이되는 서버에 설정이 필요하다면 아래와같이 친절하게 잘 알려준다.

```
NOTE: Some configuration options need to be fixed:
+----------------------------------------+---------------+----------------+--------------------------------------------------+
| Variable                               | Current Value | Required Value | Note                                             |
+----------------------------------------+---------------+----------------+--------------------------------------------------+
| binlog_transaction_dependency_tracking | COMMIT_ORDER  | WRITESET       | Update the server variable                       |
| enforce_gtid_consistency               | OFF           | ON             | Update read-only variable and restart the server |
| gtid_mode                              | OFF           | ON             | Update read-only variable and restart the server |
| server_id                              | 1             | <unique ID>    | Update read-only variable and restart the server |
+----------------------------------------+---------------+----------------+--------------------------------------------------+

```

#### MySQL 라우터 설정

- MySQL 라우터 부트스트랩 명령

```
mysqlrouter --bootstrap icadmin@localhost:3306 --name icroute1 \
--directory /tmp/myrouter --acount icrouter --user root
```

`사용된 옵션의 역할`

- `--bootstrap [mysql_uri]`
  - 이 옵션을 지정하면 MySQL 라우터가 인자로 전돨된 MySQL 서버에 접속해 해당 서버가 속한 InnoDB 클러스터의 메타데이터를 읽어들이고 이를 바탕으로 라우터 서버를 구동하는 데 필요한 파일을 모두 자동으로 생성한다.
  - InnoDB 클러스터에 라우터 서버 정보를 등록한다.
- `--name [router_name]`
  - 라우터의 이름을 지정한다. 지정한 이름은 라우터의 설정 파일에 명시되며, InnoDB 클러스터에 라우터를 등록할 때도 사용된다.
- `--directory [mysql_username]`
  - 부트스트랩 시 생성되는 디렉터리 및 파일들이 저장될 경로를 지정한다.
- `--account [mysql_username]`
  - 라우터에서 InnoDB 클러스터 내 MySQL 서버들로 접속할 때 사용할 DB 계정을 지정한다. 만약 인자로 지정한 계정이 MySQL 서버들에 존재하지 않는 경우 라우터에서 필요로 하는 최소한의 권한으로 계정을 자동 생성한다.
- `--user [os_username]`
  - 인자로 지정한 시스템 사용자 계정으로 라우터가 실행된다. 부트스트랩 시 생성되는 디렉터리 및 파일들의 소유자도 해당 사용자로 설정된다.



<br>



- InnoDB 클러스터에서 부트스트랩 시 자동으로 생성된 라우터용 DB 계정과 라우터 서버 등록 내역을 확인할 수 있다.

```sql
\sql SELECT user,host FROM mysql.user WHERE user='icrouter'


\sql SHOW GRANTS FOR 'icrouter'@'%';


//InnoDB 클러스터에 등록된 라우터 정보 확인
var cluster = dba.getCluster()
cluster.listRouters()

{
    "clusterName": "devCluster", 
    "routers": {
        "8a20d4e44168::": {
            "hostname": "8a20d4e44168", 
            "lastCheckIn": null, 
            "roPort": 6447, 
            "roXPort": 6449, 
            "rwPort": 6446, 
            "rwXPort": 6448, 
            "version": "8.0.28"
        }
    }
}
```



- 부트스트랩 명령이 완료되면 아래 네개의 포트를 사용하도록 설정된 것을 확인할 수 있다.
  - MySQL 기본 프로토콜로 연결되는 읽기 전용 포트 
  - MySQL 기본 프로토콜로 연결되는 읽기-쓰기용 포트
  - X 프로토콜로 연결되는 읽기 전용 포트
  - X 프로토콜로 연결되는 읽기-쓰기용 포트

```
vi /tmp/myrouter/mysqlrouter.conf

# File automatically generated during MySQL Router bootstrap
[DEFAULT]
logging_folder=
runtime_folder=/tmp/mysqlrouter/run
data_folder=/tmp/mysqlrouter/data
keyring_path=/tmp/mysqlrouter/data/keyring
master_key_path=/tmp/mysqlrouter/mysqlrouter.key
connect_timeout=15
read_timeout=30
dynamic_state=/tmp/mysqlrouter/data/state.json
client_ssl_cert=/tmp/mysqlrouter/data/router-cert.pem
client_ssl_key=/tmp/mysqlrouter/data/router-key.pem
client_ssl_mode=PREFERRED
server_ssl_mode=AS_CLIENT
server_ssl_verify=DISABLED

[logger]
level=INFO

[metadata_cache:devCluster]
cluster_type=gr
router_id=1
user=mysql_router1_svxffarlomj7
metadata_cluster=devCluster
ttl=0.5
auth_cache_ttl=-1
auth_cache_refresh_interval=2
use_gr_notifications=0

[routing:devCluster_rw]
bind_address=0.0.0.0
bind_port=6446
destinations=metadata-cache://devCluster/?role=PRIMARY
routing_strategy=first-available
protocol=classic

[routing:devCluster_ro]
bind_address=0.0.0.0
bind_port=6447
destinations=metadata-cache://devCluster/?role=SECONDARY
routing_strategy=round-robin-with-fallback
protocol=classic

[routing:devCluster_x_rw]
bind_address=0.0.0.0
bind_port=6448
destinations=metadata-cache://devCluster/?role=PRIMARY
routing_strategy=first-available
protocol=x

[routing:devCluster_x_ro]
bind_address=0.0.0.0
bind_port=6449
destinations=metadata-cache://devCluster/?role=SECONDARY
routing_strategy=round-robin-with-fallback
protocol=x

[http_server]
port=8443
ssl=1
ssl_cert=/tmp/mysqlrouter/data/router-cert.pem
ssl_key=/tmp/mysqlrouter/data/router-key.pem

[http_auth_realm:default_auth_realm]
backend=default_auth_backend
method=basic
name=default_realm

[rest_router]
require_realm=default_auth_realm

[rest_api]

[http_auth_backend:default_auth_backend]
backend=file
filename=/tmp/mysqlrouter/data/auth_backend_passwd_file

[rest_routing]
require_realm=default_auth_realm

[rest_metadata_cache]
require_realm=default_auth_realm
```



- 설정 파일에서 `metadata_cahce` 섹션과 `routing` 섹션은 MySQL 라우터 동작에서 가장 중요한 부분이다.
- MySQL 라우터는 내부적으로 플러그인 형태의 아키텍처로 구성되어 있는데 하나는 메타데이터 캐시 플러그인, 커넥션 라우팅 플러그인인에 대한 설정에 해당한다.
- 메타데이터 캐시 플러그인은 라우터에서 접속할 InnoDB 클러스터의 정보를 구성하고 관리하는 부분을 담당한다.
- 커넥션 라우팅 플러그인은 애플리케이션 서버로 부터 유입된 쿼리 요청을 InnoDB 클러스터로 전달하는 부분을 담당한다.
- 두 섹션에 설정돼 있는 하위 옵션 중 다음 옵션들은 필요에 따라 적절한 값으로 재설정해서 사용하는 것이 좋다.

`설정 값`

- `[metadata_cache].ttl`

  - MySQL 라우터가 내부적으로 캐싱하고 있는 클러스터 메타데이터를 갱신하는 주기를 제어하는 옵션
  - 초단위

- `[metadata_cache].use_gr_notifications`

  - 이 옵션이 활성화되면 클러스터의 그룹 복제에서 발생하는 변경사항에 대해 MySQL 라우터가 알림을 받을 수 있다.
  - MySQL 라우터는 MySQL 서버로부터 다음과 같은 경우에 대해 알림을 전달받을 수 있고 알림을 수신한 후 현재 캐싱하고 있는 클러스터 메타데이터를 갱신한다.
    - 그룹 복제에서 정족수 손실이 발생한 경우
    - 그룹 멤버 구성(그룹 뷰)에 변경이 발생한 경우
    - 그룹 멤버의 역할이 변경된 경우
    - 그룹 멤버의 상태가 변경된 경우
  - MySQL 라우터가 이러한 그룹 복제 알림을 받기 위해서는 각 클러스터 인스턴스에 X 프로토콜로 연결할 수 있어야 한다.
  - `use_gr_notifications` 옵션을 활성화해서 사용하게 되면 `ttl` 옵션에 설정된 갱신 주기는 추가적인 보조수단이 되므로 `ttl` 값을 적절히 큰 값으로 설정해도 무방하다.

- `[routing].destinations`

  - MySQL 라우터에서 쿼리 요청을 전달할 대상 MySQL 서버를 지정하는 옵션
  - 정적인 형태는 아래와 같이 MySQL 서버들을 고정된 값으로 지정한 것을 의미한다.

  ```
  destinations=192.168.35.2, ... , ...
  ```

  - 동적인 형태는 메타데이터 캐시에서 대상 서버들을 조회하는 형태로 다음과 같은 URI 포맷을 띤다.
  - 기본적으로 동적인 형태가 자동으로 설정된다.

  ```
  destinations=metadata-cache://testCluster/?role=PRIMARY
  ```

  - URI에서는 다음의 세 옵션을 사용할 수 있다.

    - `role`

      - 어떤 타입의 MySQL 서버로 연결할 것인지 설정하는 옵션
      - `PRIMARY`, `SECONDARY`, `PRIMARY_AND_SECONDARY` 값으로 설정 가능하다.

    - `disconnect_on_promoted_to_primary`

      - 클러스터에서 세컨더리 서버가 프라이머리로 승격 됐을 때 해당 서버에 대한 기존 클라이언트 연결을 종료할 것인지 여부를 제어한다.

    - `disconnect_on_metadata_unavailable`

      - 클러스터 과부하 등으로 인해 MySQL 라우터에서 클러스터의 메타데이터 갱신이 불가할 때 클러스터에 대한 기존 클라이언트 연결을 모두 종료할 것인지 여부를 제어한다.
      - 기본값은 `no`
      - 이 옵션은 MySQL 라우터 8.0.12 부터 사용 가능하다.

    - 아래와 같은 형태로 조합해서 사용 가능하다.

      ```
      destination=metadata-cache://testCluster/?role=SECONDARY&disconnect_on_promoted_to_primary=yes
      ```

- `[routing].routing_strategy`

  - MySQL 라우터가 어떤 MySQL 서버에 연결해서 쿼리 요청을 전달할 것인지 연결 대상 서버를 선택하는 방식을 제어하는 옵션이다.
  - `destination` 옵션에 지정된 서버들이 연결 대상 서버가 되고 MySQL 라우터에 새로 연결이 필요할 때마다 `routing_strategy` 옵션에 설정된 값을 바탕으로 연결 대상 서버들 중에서 최종적으로 연결할 서버를 선택하게 된다.
  - `routing_strategy`은 다음의 네가지 옵션을 사용할 수 있다.
    - `round-robin`
      - 연결 대상 서버들에 대해 라운드 로빈 방식으로 연결할 서버를 선택한다.
    - `round-robin-with-fallback`
      - 세컨더리 서버들에 대해 라운드 로빈 방식으로 연결할 서버를 선택하며, 클러스터에 연결 가능한 세컨더리 서버가 존재하지 않는 경우 프라이머리 서버들에 대해 라운드 로빈 방식으로 연결할 서버를 선택하게 된다.
    - `first-available`
      - 연결 대상 서버 목록에서 사용 가능한 첫 번쨰 서버에 연결한다.
      - 에러가 발생하면 사용 가능한 다음 서버로 다시 연결을 시도하고 연결 대상 서버 목록에 더이상 연결을 시도할 서버가 존재하지 않을 때까지 계속된다.
    - `next-available`
      - `first-available` 방식과 동일하나 연결 오류 시 오류가 발생한 서버에 대해 연결 불가로 표시하고 연결 대상에서 제외한다.
      - 한번 제외된 서버는 MySQL 라우터가 재시작될 때까지 연결 대상에 포함되지 않는다.
      - 이 방식은 메타데이터 캐시를 사용하는 경우엔 지원하지 않고 `destinations`에 정적으로 서버들을 지정한 경우에만 사용 가능하다.
  - `routing_strategy` 옵션은 `destinations`에 지정된 `role` 별로 기본으로 설정되는 값과 설정 가능한 값들이 달라진다.
    - `role`이 `PRIMARY`로 지정된 경우
      - 기본적으로 `round-robin`으로 동작
      - MySQL 라우터가 부트스트랩 명령으로 구성된 경우 설정 파일에 `first-available` 방식이 자동으로 지정
      - `round-robin`, `first-available` 만 지정 가능
    - `role`이 `SECONDARY`로 지정된 경우
      - 기본적으로 `round-robin`으로 동작
      - MySQL 라우터가 부트스트랩 명령으로 구성된 경우 설정 파일에 `round-robin-with-fallback` 방식이 자동으로 지정
      - `round-robin`, `first-available`, `round-robin-with-fallback` 만 지정 가능
    - `role`이 `PRIMARY_AND_SECONDARY`로 지정된 경우
      - 기본적으로 `round-robin`으로 동작
      - `round-robin`, `first-available` 만 지정 가능

<br>

<br>

- MySQL 라우터에 대한 부트스트랩이 완료되면 라우터는 자동으로 실행되지 않으므로 다음과 같이 수동으로 실행한다.

```
/tmp/myrouter/start.sh


# netstat으로 4개의 TCP 포트 확인
netstat -lntp | grep mysqlrouter
```

- 클라이언트는 더이상 InnoDB 클러스터에 연결하지 않고 MySQL 라우터로 연결한다는 점이다.
- 라우터를 통해 실제 쿼리가 어디 서버에 전달되었는지 확인하려면 간단하게 `hostname`과 `port` 시스템 변수를 조회하면된다.

```
// 라우터의 기본 쓰기 포트(6446)로 연결해서 쿼리 실행
\connect icadmin@mysql-router-server1:6466
\sql SELECT @@hostname, @@port;

+--------------+--------+
| @@hostname   | @@port |
+--------------+--------+
| 30f50168f043 |   3306 |
+--------------+--------+
1 row in set (0.0020 sec)


```

- 쓰기 포트로 연결한 경우 실행 쿼리는 프라이머리 서버로 전달되며 읽기 포트로 연결해서 실행한 쿼리는 세컨더리 서버들 중 한 서버로 전달된다.



## InnoDB 클러스터 모니터링

- MySQL 셸을 통해 InnoDB 클러스터 구성의 전반적인 상태를 확인할 수 있다.
- 클러스터의 복제 토폴로지 구성을 간략하게 확인하고 싶은 경우 `<Cluster>.describe()` 메서드를 사용하면 된다.

```
cluster.describe()

{
    "clusterName": "devCluster", 
    "defaultReplicaSet": {
        "name": "default", 
        "topology": [
            {
                "address": "mysql-server-1:3306", 
                "label": "mysql-server-1:3306", 
                "role": "HA"
            }, 
            {
                "address": "mysql-server-2:3306", 
                "label": "mysql-server-2:3306", 
                "role": "HA"
            }, 
            {
                "address": "mysql-server-3:3306", 
                "label": "mysql-server-3:3306", 
                "role": "HA"
            }
        ], 
        "topologyMode": "Single-Primary"
    }
}

```

- 클러스터의 전반적인 상태를 좀 더 자세하게 사용하고 싶다면 아래와 같이 사용할 수 있다.

```
cluster.status({'extended':1})

{
    "clusterName": "devCluster", 
    "defaultReplicaSet": {
        "GRProtocolVersion": "5.7.14", 
        "groupName": "ee891ea8-b6d2-11ec-8166-0242ac130004", 
        "groupViewId": "16493777624982331:3", 
        "name": "default", 
        "primary": "mysql-server-1:3306", 
        "ssl": "REQUIRED", 
        "status": "OK", 
        "statusText": "Cluster is ONLINE and can tolerate up to ONE failure.", 
        "topology": {
            "mysql-server-1:3306": {
                "address": "mysql-server-1:3306", 
                "fenceSysVars": [], 
                "instanceErrors": [
                    "NOTE: instance server_id is not registered in the metadata. Use cluster.rescan() to update the metadata."
                ], 
                "memberId": "e641a1c3-b6d2-11ec-a521-0242ac130004", 
                "memberRole": "PRIMARY", 
                "memberState": "(MISSING)", 
                "mode": "n/a", 
                "readReplicas": {}, 
                "role": "HA", 
                "shellConnectError": "MySQL Error 2005: Could not open connection to 'mysql-server-1:3306': Unknown MySQL server host 'mysql-server-1' (8)", 
                "status": "ONLINE", 
                "version": "8.0.12"
            }, 
            "mysql-server-2:3306": {
                "address": "mysql-server-2:3306", 
                "fenceSysVars": [], 
                "instanceErrors": [
                    "NOTE: instance server_id is not registered in the metadata. Use cluster.rescan() to update the metadata."
                ], 
                "memberId": "e64abc99-b6d2-11ec-a577-0242ac130003", 
                "memberRole": "SECONDARY", 
                "memberState": "(MISSING)", 
                "mode": "n/a", 
                "readReplicas": {}, 
                "role": "HA", 
                "shellConnectError": "MySQL Error 2005: Could not open connection to 'mysql-server-2:3306': Unknown MySQL server host 'mysql-server-2' (8)", 
                "status": "ONLINE", 
                "version": "8.0.12"
            }, 
            "mysql-server-3:3306": {
                "address": "mysql-server-3:3306", 
                "fenceSysVars": [], 
                "instanceErrors": [
                    "NOTE: instance server_id is not registered in the metadata. Use cluster.rescan() to update the metadata."
                ], 
                "memberId": "e640e885-b6d2-11ec-a5f2-0242ac130002", 
                "memberRole": "SECONDARY", 
                "memberState": "(MISSING)", 
                "mode": "n/a", 
                "readReplicas": {}, 
                "role": "HA", 
                "shellConnectError": "MySQL Error 2005: Could not open connection to 'mysql-server-3:3306': Unknown MySQL server host 'mysql-server-3' (8)", 
                "status": "ONLINE", 
                "version": "8.0.12"
            }
        }, 
        "topologyMode": "Single-Primary"
    }, 
    "groupInformationSourceMember": "30f50168f043:3306", 
    "metadataVersion": "1.0.1"
}

```

 `일반적인 status()에서 추가된 부분`

- `GRProtocolVersion`
  - 클러스터의 그룹 복제에서 사용하는 통신 프로토콜 버전을 나타낸다.
- `groupName`
  - 클러스터의 그룹 복제에 설정된 그룹 이름을 나타낸다.
- `fenceSysVar`
  - 각 클러스터 인스턴스에서 활성화돼 있는 차단 시스템 변수들의 목록이 보여진다
  - `read_only`와 `super_read_only`, `offline_mode` 변수가 해당 목록에 보여질 수 있다.
- `memberId`
  - 각 클러스터 인스턴스들의 UUID를 나타낸다.
- `memberRole`
  - 클러스터의 그룹 복제에서 인스턴스의 역할을 나타낸다.
- `memberState`
  - 클러스터의 그룹 복제에서 각 클러스터 인스턴스들의 상태를 나타낸다.
- `metadataVersion`
  - MySQL 셸에서 InnoDB 클러스터 관리를 위해 생성한 클러스터 메타데이터 스키마의 버전을 나타낸다.



<br>

<br>

- `<Cluster>.status()` 메서드는 어떠한 옵션도 지정하지 않고 실행하면 기본적으로 `extended` 옵션이 0이다.

`extended 옵션, (MySQL 셸 8.0.17미만에서는 0 or 1만 가능)`

- 0: 기본적으로 설정되는 값, 추가적인 정보를 출력하지 않는다.
- 1: 클러스터의 그룹 복제 통신 프로토콜 버전, 그룹 이름. 각 클러스터 인스턴스들의 그룹 복제에서의 역할 및 상태, 차단 시스템 목록과 클러스터 메타데이터 스키마 버전이 추가로 표시된다.
- 2: 각 클러스터 인스턴스에서 처리된 트랜잭션에 대한 통계 정보가 추가로 표시된다.
- 3: 각 클러스터 인스턴스의 복제 커넥션 및 복제 처리 스레드에 대한 통계 정보가 추가로 표시된다.



## InnoDB 클러스터 작업

### 클러스터 모드 변경

- InnoDB 클러스터는 기본적으로 싱글 프라이머리 모드로 생성된다.
- 상황에 따라 멀티 프라이머리 모드로 전환하고 싶을때 InnoDB 클러스터의 구성 요소들의 버전이 모두 8.0.14 이상인 경우 이러한 클러스터 모드 변경을 클러스터를 중단하지 않고 온라인으로 수행할 수 있고 MySQL 셸에서 손쉽게 사용 가능하다.
- 8.0.14 버전 미만인 경우 클러스터를 해체 후 다시 원하는 모드로 설정해서 재생성 해야만 변경 가능하다.

`클러스터 변경 메서드`

- `<Cluster>.switchToMultiPrimaryMode()`
  - 클러스터를 멀티 프라이머리 모드로 전환한다.
  - 클러스터를 구성하는 모든 MySQL 서버는 프라이머리로 동작한다.
- `<Cluster>.switchToSinglePrimaryMode([instance])`
  - 클러스터를 싱글 프라이머리 모드로 전환한다.
  - 명령어의 인자로 프라이머리가 될 서버를 지정할 수 있다. 그 외의 모든 서버들은 세컨더리로 동작하게 된다.
  - 서버가 지정하지 않은 경우 그룹 복제의 프라이머리 선출 로직에 따라 자동으로 지정된다.
  - 멀티 프라이머리 모드에서 싱글 프라이머리 모드로 전환할 때 클라이언트 단에서는 일시적으로 쓰기 에러가 발생할 수도 있다.



### 프라이머리 변경

- InnoDB 클러스터 구성원들의 버전이 모두 8.0.14이상인 경우 사용자는 현재 싱글 프라이머리 모드로 동작중인 클러스터의 프라이머리 서버를 강제로 특정 서버로 변경할 수 있다.
- `<Cluster>.setPrimaryInstance(instance)`
  - 인자로 주어진 서버를 클러스터의 새로운 프라이머리 서버로 설정한다.
  - 이 과정에서 기존 프라이머리 서버로 유입된 쓰기 요청들 중 일부에 일시적으로 에러가 발생할 수 있다.



### 인스턴스 제거

- 서버 교체나 장애 등의 문제로 클러스터의 특정 인스턴스를 제거해야하는 경우 다음 메서드를 사용할 수 있다.
- `<Cluster>.removeInstance(instance)`
  - 인자로 지정된 서버를 클러스터에서 제거한다.
  - 클러스터 내 온라인 상태의 모든 서버들의 메타데이터에서 제거 대상 서버 정보를 삭제하며, 제거 대상 서버의 분산 복구용 복제 계정을 클러스터에서 제거하는 등의 작업이 내부적으로 진행된다.
  - 제거된 서버에서 저장된 데이터는 그대로 남아 있다.

<br>

<br>

- 서버를 제거하는 시점에 제거 대상 서버에 아직 적용되지 못한 클러스터의 트랜잭션이 존재할 수 있는데 이 경우 제거 명령은 `dba.gtidWaitTimeout` 옵션에 설정된 시간만큼 기다린다. (기본값은 60초)

```
shell.options['dba.gtidWaitTimeout']

shell.options['dba.gtidWaitTimeout']=180
```

- `dba.gtidWaitTimeout` 에 설정된 시간이 초과하면 제거 실행이 중단된다.
- `dba.gtidWaitTimeout` 옵션에 설정된 시간이 초과하더라도 서버를 클러스터에서 강제로 제거하려면 제거 명령에 "{force:true}" 옵션을 지정하면 된다.
- 위 방법은 제거 대상 서버에 적용이 누락된 클러스터의 트랜잭션이 존재할 수 있고 이로 인해 나중에 클러스터에 다시 참여하지 못할 수 있기 때문에 제거 대상 서버를 더이상 클러스터에서 사용하지 않을 예정인 경우에만 해당 옵션을 사용하는 것이 좋다.

```
cluster.removeInstance('icadmin@ic-node3:3306', {force:true})
```



### 클러스터 해체

- 클러스터의 사용 종료 혹은 클러스터 단위의 설정 변경 등으로 클러스터를 해체 후 재생성하고자 할 때 MySQL 셸에서 클러스터를 해체할 수 있다.
- `<Cluster>.dissolve()`
  - 메서드를 실행할 때 클러스터의 MySQL 서버들에서 클러스터와 관련된 모든 메타데이터 및 설정, 계정 등을 삭제하고 그룹 복제를 중단시킨다.
  - 각 서버에 저장된 데이터는 삭제되지 않는다.
- 마찬가지로 `dba.gtidWaitTimeout` 만큼 대기하고 이 시간을 초과하면 해체 명령이 중지된다.
- "{force:true}" 옵션 설정이 가능하다.
- 해체 작업 과정에서 누락된 서버가 존재하면 경우에 따라 스플릿 브레인 상황이 발생할 수 있기 때문에 이러한 부분이 전혀 문제가 되지 않을 것으로 예상되는 경우에만 해체 작업을 진행하는 것이 좋다.



### 클러스터 및 인스턴스 설정 변경

- 클러스터의 현재 설정을 확인하려면 `<Cluster>.options()` 메서드를 사용해서 클러스터의 이름, 클러스터의 전역 설정, 태그 정보, 클러스터의 각 서버의 설정 정보를 JSON 포맷으로 확인할 수 있다.

```
cluster.options()
```

-  `<Cluster>.options()` 에 "{all:true}" 옵션을 주면 각 인스턴스의 그룹 복제와 관련된 전체 설정을 확인할 수 있다.

```
cluster.options({all:true})
```

- 사용자는 아래 두 메서드를 사용해 클러스터 및 인스턴스 설정을 변경할 수 있다. 현재까지 모든 설정들을 변경할 수 있지 않고 특정 설정만 변경할 수 있고 MySQL 셸 버전에 따라 변경 가능한 설정이 다르므로 참고하자.

`클러스터 설정 변경`

- `<Cluster>.setOption(option, value)`
  - 클러스터의 모든 인스턴스에 대해 설정을 변경하거나 클러스터 단위의 설정을 변경한다.
  - `option`에는값을 변경할 설정, `value` 는 새롭게 적용할 값을 입력한다.
  - 이 메서드를 통해 변경할 수 있는 설정
    - `tag:<option>`: 클러스터의 태그를 설정한다. `<option>`에는 설정할 태그의 이름을 명시한다.
    - `clusterName`: 클러스터의 이름을 변경한다.
    - `exitStateAction`: 그룹 복제의 종료 액션을 설정한다. 클러스터의 모든 인스턴스에 대해 지정된 값이 동일하게 적용된다.
    - `memberWeight`: 클러스터에 새로운 프라이머리를 선출할 때 사용되는 가중치 백분율을 설정한다. 클러스터의 모든 인스턴스에 대해 지정된 값이 동일하게 적용된다.
    - `consistency`: 클러스터의 일관성 레벨을 설정한다. 클러스터의 모든 인스턴스에 대해 지정된 값이 동일하게 적용된다.
    - `expelTimeout`: 클러스터에서 인스턴스가 강제 추방되기 전 대기할 시간을 설정한다. 클러스터의 모든 인스턴스에 대해 지정된 값이 동일하게 적용된다.
    - `autoRejoinTries`: 클러스터 탈퇴 후 자동으로 재가입을 시도하는 횟수를 설정한다. 클러스터의 모든 인스턴스에 대해 지정된 값이 동일하게 적용된다.
    - `disableClone`: 클러스터에서 분산 복구 방식 중 하나인 원격 클론 방식의 사용 여부를 설정한다.
- `<Cluster>.setInstanceOption(instance, option, value)`
  - 클러스터 인스턴스별로 설정을 변경한다.
  - `instance`에는 설정을 변경할 인스턴스를 지정하고 `option`에는값을 변경할 설정, `value` 는 새롭게 적용할 값을 입력한다.
  - 이 메서드를 통해 변경할 수 있는 설정
    - `tag:<option>`: 클러스터의 태그를 설정한다. `<option>`에는 설정할 태그의 이름을 명시한다.
    - `exitStateAction`: 그룹 복제의 종료 액션을 설정한다. 
    - `memberWeight`: 클러스터에 새로운 프라이머리를 선출할 때 사용되는 가중치 백분율을 설정한다. 
    - `autoRejoinTries`: 클러스터 탈퇴 후 자동으로 재가입을 시도하는 횟수를 설정한다. 
    - `label:` 클러스터 구성 정보에 표시되는 인스턴스의 식별자를 변경한다.



#### 빌트인 태그

- 사용자는 클러스터 및 인스턴스에 태그를 설정할 수 있고 이런 태그 기능은 MySQL 셸 8.0.21 이상의 버전부터 사용 가능하다.
- 사용자는 태그를 설정할때 태그의 Key-Value 값을 자유롭게 지정할 수 있지만 예외적으로 태그의 키값은 언더스코어(`_`) 로 시작할 수 없다. MySQL에서 언더스코어로 시작하는 태그는 내부적으로 미리 정의된 빌트인 태그로 인식하기 때문이다.

`빌트인 태그`

- `_hidden`
  - `true` 혹은 `false` 로 설정
  - 인스턴스에 이 태그값이 `true` 로 설정된 경우 MySQL 라우터에서는 해당 인스턴스로 쿼리 요청을 전달하지 않는다.
- `_disconnect_existing_sessions_when_hidden`
  - `true` 혹은 `false` 로 설정
  - 인스턴스에 이 태그의 값이 `true` 로 설정돼 있고 `_hidden` 태그 도 `true` 로 설정된 경우 MySQL 라우터는 해당 인스턴스에 연결된 커넥션을 끊는다.
  - 이 태그는 사용자가 명시적으로 설정하지 않더라도 기본적으로  `true` 로 설정된 것으로 간주된다.

<br>

<br>

- 빌트인 태그를 사용하면 유인되는 클라이언트 쿼리 요청으로부터 특정 인스턴스를 숨길 수 있다.

`유용한 case`

- 클러스터 인스턴스들을 순차적으로 버전 업그레이드하는 것과 같이 MySQL 서버 운영 작업을 진행하는 경우
- 복제 지연이 발생한 인스턴스를 일시적으로 클라이언트 쿼리 요청에서 제외시키는 경우
- 클라이언트에서 실행한 쿼리에 영향을 줄 수 있는 백업이 수행되거나 혹은 분석 전용으로 사용되는 인스턴스 클라이언트 쿼리 요청에서 제외시키는 경우



## InnoDB 클러스터 트러블 슈팅

### 클러스터 인스턴스 장애

- 클러스터의 인스턴스들은 기본적으로 5초동안 인스턴스가 응답이 없으면 클러스터의 다른 인스턴스들이 해당 인스턴스에 문제가 있는 것으로 간주하며 클러스터 인스턴스들은 `expelTimeout` 옵션에 설정된 시간만큼 추가적으로 대기 후 최종적으로 응답이 없는 인스턴스를 클러스터의 그룹 복제에서 내보낸다.
- 인스턴스가 네트워크 문제로 통신이 단절되고 통신이 회복되면 클러스터는 자동으로 `autoRejoinTries` 옵션에 설정된 횟수만큼 재연결 시도를 한다.
- 만약 `autoRejoinTries` 옵션에 설정된 횟수만큼 시도해도 클러스터에 연결하지 못하면 `exitStateAction` 옵션에 설정된 조치를 수행한다. 이 경우 인스턴스가 클러스터에 다시 연결되려면 사용자의 개입이 필요하다.
- 사용자는 MySQL 셸에서 `<Cluster>.rejoinInstance(instance)` 메서드를 실행해 인스턴스를 클러스터에 다시 참여시킬 수 있다.



### 클러스터의 정족수 손실

- 클러스터에서 과반수 이상의 인스턴스에 장애가 발생한 경우 클러스터는 쓰기 요청과 토폴로지 변경을 처리할 수 없다. 과반수의 인스턴스에 대한 동의가 필요하기 때문이다.
- 정족수가 손실된다면 반드시 사용자의 개입이 필요하다.
- 사용자는 MySQL 셸에서 `<Cluster>.forceQuorumUsingPartitionOf(instance)` 메서드를 사용해 클러스터를 강제로 재구성할 수 있다. 이 명령은 인자로 지정한 인스턴스에 접속해 해당 인스턴스에 정상적인 상태로 인식되는 클러스터 내 다른 인스턴스를 확인한 후 그 인스턴스들로 클러스터를 재구성한다.

## InnoDB 클러스터 버전 업그레이드

- 클러스터는 여러 요소로 구성되므로 아래와 같이 안전하게 업그레이드를 진행하는것을 권장한다.
  1. MySQL 라우터 업그레이드
  2. MySQL 셸 및 InnoDB 클러스터 메타데이터 스키마 업그레이드
  3. MySQL 인스턴스 업그레이드 (세컨더리부터 프라이머리까지)
- 클러스터 버전 업그레이드에는 `_hidden` 옵션을 활용하는 것이 좋다.
- 싱글 프라이머리 모드 클러스터의 인스턴스 롤링 업그레이드

![101](https://github.com/sup2is/dev-note/blob/master/db/mysql/images/real-mysql-8/101.jpeg)





## InnoDB 클러스터 제약 사항

- InnoDB 클러스터는 그룹 복제를 기반으로 구성되므로 클러스터의 제약 사항은 기본적으로 그룹 복제의 제약사항들을 포함하며 추가로 다음과 같은 제약사항이 있다.

`제약사항`

- InnoDB 클러스터 인스턴스들에서는 `--defaults_extra-file` 옵션을 사용해 추가적인 옵션 파일을 지정해 사용할 수 없다.
- InnoDB 클러스터는 인스턴스에 수동으로 구성된 별도의 복제 채널을 관리하지 않는다. 이는 그룹 복제 및 MySQL 셸의 Admin API에서 내부적으로 클러스터에 대한 작업을 수행할 때 이러한 별도 복제 채널이 프라이머리 인스턴스에서만 동작하는지 확인한 후 작업을 진행하지 않는 것을 의미하며, 이로 인해 추후 클러스터 인스턴스 간의 데이터가 일치하지 않는 문제가 발생할 수도 있다.
- InnoDB 클러스터는 여러 개의 InnoDB 클러스터에 데이터가 분산되어 저장되게 하는 샤딩 형태는 지원하지 않는다. MySQL 라우터는 하나의 InnoDB 클러스터에 대해서만 설정 가능하다.

